<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tzb.electoral_systems.election API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tzb.electoral_systems.election</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Set, Optional, List, Union
from math import sqrt
from random import random

from .utls import Singleton, NameIterator, IdIterator
from .election_constants import RandomConstants, VotingRulesConstants
from .extensions.polls import (
    add_elector_data,
    add_candidate_data,
    get_default_directions_data,
    set_avg_electors_positions,
    set_std_deviation,
    change_position_candidates,
    change_ranking_electors,
)
from .extensions.liquid_democracy import choose_delegee, choose_possible_delegees
from .voting_rules.utls import set_duels_scores, sort_cand_by_value, sort_cand_by_round

from people import Candidate, Elector


class Election(metaclass=Singleton):
    &#34;&#34;&#34;Une classe Singleton qui contient toutes les données nécessaires pour une élection.&#34;&#34;&#34;

    def __init__(self):
        super().__init__()
        self.electors = []
        self.candidates = []

        # Générer les prénoms, les noms
        self.first_name_iter = NameIterator()
        self.last_name_iter = NameIterator()

        # Générer les IDs
        self.id_iter = IdIterator(0)

        # Stocker des resultats
        self.results = dict()
        # Stocker des duels
        self.duels_scores = dict()

        # Pour satisfaction
        self.average_position_electors = (0, 0)
        self.proportion_satisfaction = 0

        # Init constantes
        self.set_default_settings()

    def set_default_settings(self) -&gt; None:
        &#34;&#34;&#34;Initialiser des réglages par défaut&#34;&#34;&#34;

        # Nb des sondages à faire
        self.nb_polls = 0

        # Activer/désactiver une démocratie liquide
        self.liquid_democracy_activated = False

        # Une règle du vote pour des sondages
        self.poll_voting_rule = VotingRulesConstants.PLURALITY_SIMPLE

        # Activer/désactiver un tie-break selon les duels
        self.tie_breaker_activated = True

        # Des constantes de la génération des données
        self.generation_constants = dict()
        for type, default_value in RandomConstants.DEFAULT_VALUES.items():
            self.generation_constants[type] = default_value

        # Pour sondages uniquement. Stocker les données pour chaque direction (division) de la carte politique
        self.directions_data = get_default_directions_data()

    def _init_results_keys(self, set_keys: Set[str]) -&gt; None:
        &#34;&#34;&#34;Initialiser des clés du dictionnaire `results` avec des constantes associées aux règles du vote choisies.
        Les valeurs sont rémies à `None`.
        &#34;&#34;&#34;

        for key in set_keys:
            self.results[key] = None

    def _calc_distance(self, point1: tuple[float, float], point2: tuple[float, float]) -&gt; float:
        &#34;&#34;&#34;Calculer la distance euclidienne entre 2 points.

        Args:
            point1 (tuple[float, float]): position sur la carte politique
            point2 (tuple[float, float]): position sur la carte politique
        Returns:
            float: Une distance euclidienne entre 2 points.
        &#34;&#34;&#34;
        x1, y1 = point1
        x2, y2 = point2
        return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)

    def has_electors_candidates(self) -&gt; bool:
        &#34;&#34;&#34;Vérifier qu&#39;il existe au moins un électeur et un candidat dans une élection.

        Returns:
            bool: True ssi il existe au moins un électeur et un candidat dans une élection, sinon False.
        &#34;&#34;&#34;
        if not self.electors and not self.candidates:
            return False
        return True

    def add_elector_import(self, new_elector: Elector) -&gt; None:
        &#34;&#34;&#34;Ajouter un électeur déjà dont les données déjà sont initialisées.
        Si les sondages sont activées, MAJ les données sur les directions de la carte politique.
        MAJ des données sur la position moyenne de tous les électeurs participand dans une élection.
        Utilisée lors d&#39;une importation des données.

        Args:
            new_elector (people.elector.Elector): Un nouveau électeur.
        &#34;&#34;&#34;

        if self.nb_polls:
            add_elector_data(self.directions_data, new_elector)

        x, y = new_elector.position
        x_avg, y_avg = self.average_position_electors
        x_avg, y_avg = x_avg + x, y_avg + y
        self.average_position_electors = (x_avg, y_avg)

        self.electors.append(new_elector)

    def add_elector(self, position: tuple[float, float]) -&gt; None:
        &#34;&#34;&#34;Ajouter un nouveau électeur dans une élection avec la position `position`.
        Si les sondages sont activées, MAJ les données sur les directions de la carte politique.
        MAJ des données sur la position moyenne de tous les électeurs participand dans une élection.

        Args:
            position (tuple[float, float]): Une position d&#39;un électeur sur la carte politique.
                Chaque coordonnée doit être borné entre -1 et 1.
        &#34;&#34;&#34;

        knowledge_const = self.generation_constants[RandomConstants.KNOWLEDGE]
        new_elector = Elector(
            id=next(self.id_iter), position=position, knowledge_const=knowledge_const
        )
        x, y = new_elector.position

        if self.nb_polls:
            add_elector_data(self.directions_data, new_elector)

        # All electors average
        x_avg, y_avg = self.average_position_electors
        x_avg, y_avg = x_avg + x, y_avg + y
        self.average_position_electors = (x_avg, y_avg)
        self.electors.append(new_elector)

    def add_candidate_import(self, new_candidate: Candidate) -&gt; None:
        &#34;&#34;&#34;Ajouter un candidat déjà dont les données déjà sont initialisées.
        Si les sondages sont activées, MAJ les données sur les directions de la carte politique.
        Utilisée lors d&#39;une importation des données.

        Args:
            new_elector (people.elector.Elector): un nouveau électeur.
        &#34;&#34;&#34;

        self.candidates.append(new_candidate)
        if self.nb_polls:
            add_candidate_data(self.directions_data, new_candidate)

    def add_candidate(self, position: tuple[float, float], first_name: Optional[str] = &#34;&#34;, last_name: Optional[str] = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;Ajouter un nouveau candidat dans une élection avec la position `position`, et éventuellement
        le prénom et le nom.
        Si les sondages sont activées, MAJ les données sur les directions de la carte politique.

        Args:
            position (tuple[float, float]): Une position d&#39;un candidat sur la carte politique.
                Chaque coordonnée doit être borné entre -1 et 1.
            first_name (Optional[str]): Un prénom d&#39;un candidat.
            last_name (Optional[str]): Un nom d&#39;un candidat.
        &#34;&#34;&#34;

        dogmat_const = self.generation_constants[RandomConstants.DOGMATISM]
        oppos_const = self.generation_constants[RandomConstants.OPPOSITION]

        first_name = next(self.first_name_iter) if not first_name else first_name
        last_name = next(self.last_name_iter) if not last_name else last_name

        new_candidate = Candidate(
            id=next(self.id_iter),
            position=position,
            first_name=first_name,
            last_name=last_name,
            dogmatism_const=dogmat_const,
            opposition_const=oppos_const,
        )
        if self.nb_polls:
            add_candidate_data(self.directions_data, new_candidate)

        self.candidates.append(new_candidate)

    def apply_voting_rule(self, voting_rule: str) -&gt; None:
        &#34;&#34;&#34;Appliquer une règle du vote `voting_rule`. Remplir une case correspondante à `voting_rule` du dictionnaire `results`
        avec une liste (un classement) des candidats. La fonction est appliquée uniquement s&#39;il existe au moins un électeur
        et un candidate, sinon elle fait rien.

        Args:
            voting_rule (str): Une constante correspondante à une règle du vote.
        &#34;&#34;&#34;

        if not self.has_electors_candidates():
            return

        result = []
        func = VotingRulesConstants.VOTING_RULES_FUNC[voting_rule]

        if voting_rule in VotingRulesConstants.CONDORCET:
            result = func(self.electors, self.candidates, self.duels_scores)

        elif voting_rule == VotingRulesConstants.APPROVAL:
            result = func(
                self.electors,
                self.candidates,
                VotingRulesConstants.APPROVAL_GAP_COEF,
                self.duels_scores if self.tie_breaker_activated else None,
            )
        else:
            result = func(
                self.electors,
                self.candidates,
                self.duels_scores if self.tie_breaker_activated else None,
            )

        self.results[voting_rule] = result

    def choose_winner(self, voting_rule: str) -&gt; Union[Candidate, None]:
        &#34;&#34;&#34;Choisir un gagnant d&#39;une règle du vote `voting_rule` selon les règles.

        Args:
            voting_rule (str): Une constante correspondante à une règle du vote.

        Returns:
            Union[Candidate, None]: Un candidat-gagnant. Peut retourner `None` dans un condorcet simple ou
                si le classement associé à `voting_rule` est vide.
        &#34;&#34;&#34;
        if voting_rule not in self.results:
            self.apply_voting_rule(voting_rule)

        if not len(self.results[voting_rule]):
            return None

        if voting_rule in VotingRulesConstants.MULTI_ROUND:
            return self.results[voting_rule][-1][0]

        if voting_rule == VotingRulesConstants.CONDORCET_SIMPLE:
            return self.choose_condorcet_winner()

        return self.results[voting_rule][0]

    def choose_condorcet_winner(self) -&gt; Union[Candidate, None]:
        &#34;&#34;&#34;Choisir un gagnant dans une règle du vote Condorcet simple. Un gagnant est un candidat que bat
        tous les autres candidats dans les duels.

        Returns:
            Union[Candidate, None]: Un candidat du Condorcet s&#39;il existe, sinon None.
        &#34;&#34;&#34;

        fst_candidate = self.results[VotingRulesConstants.CONDORCET_SIMPLE][0]
        score = fst_candidate.scores[VotingRulesConstants.CONDORCET_SIMPLE]
        return fst_candidate if score == len(self.candidates) - 1 else None

    def _define_ranking(self) -&gt; None:
        &#34;&#34;&#34;Faire chaque electeur classer des candidats. Doit être appelée uniquement quand tous les candidats ont été ajoutés.&#34;&#34;&#34;

        for elector in self.electors:
            elector.rank_candidates(self.candidates)

    def calc_results(self, imported: Optional[bool] = False) -&gt; None:
        &#34;&#34;&#34;Calculer des résultats d&#39;une élection, i.e. Calculer les duels entre les candidats, attribuer des scores aux candidats, 
        et calculer des classements des candidats dans chaque règle du vote choisie.

        Args:
            imported (bool): True si les données one été importés. Si oui, ne pas calculer des duels et des scores des candidats
                dans chaque règle du vote choisie. Ils sont importés. Cepedant, un calcul des classement est effectué.
        &#34;&#34;&#34;

        if imported:
            # Duels sont importés dans sqlite.ImportData
            self.set_results()
            return

        self.duels_scores = set_duels_scores(self.electors, self.candidates)
        for voting_rule in self.results:
            self.apply_voting_rule(voting_rule)

    def set_avg_electors_position(self) -&gt; None:
        &#34;&#34;&#34;Calculer une position moyenne des électeurs. Uniquement la division est faite. La somme de toutes les positions
        est déjà stockée.&#34;&#34;&#34;

        x_avg, y_avg = self.average_position_electors
        x_avg /= len(self.electors)
        y_avg /= len(self.electors)
        self.average_position_electors = (x_avg, y_avg)

    def _calc_proportion_satisfaction(self) -&gt; None:
        &#34;&#34;&#34;Calculer le taux d&#39;une satisfaction de la population.&#34;&#34;&#34;

        proportion = 0
        for candidate in self.candidates:
            dist_cand_electors = self._calc_distance(
                candidate.position, self.average_position_electors
            )
            proportion = max(proportion, dist_cand_electors)
        self.proportion_satisfaction = proportion

    def calc_satisfaction(self, candidate: Candidate) -&gt; float:
        &#34;&#34;&#34;Calculer le pourcentage de la population qui est satisfait par une victoire du candidat `candidate` dans une élection.

        Args:
            candidate (people.candidate.Candidate): Un candidat-gagnant.

        Returns:
            float: Le pourcentage de la population.
        &#34;&#34;&#34;
        diff = abs(
            self._calc_distance(candidate.position, self.average_position_electors)
            - self.proportion_satisfaction
        )
        percentage = (
            diff / self.proportion_satisfaction * 100
            if self.proportion_satisfaction != 0
            else 0
        )
        return percentage

    def set_results(self) -&gt; None:
        &#34;&#34;&#34;Calculer un classement des candidats selon leurs scores (les scores sont déjà attribués à chaque candidat).
        Utilisée lors de l&#39;importation des données. MAJ d&#39;un dictionnaire `results`. La fonction fait rien s&#39;il n&#39;existe pas 
        au moins un électeur et un candidat.
        &#34;&#34;&#34;

        if not self.has_electors_candidates():
            return
        # Assuming every candidate has the same voting_rules
        candidate = self.candidates[0]
        keys = candidate.scores.keys()

        duels = self.duels_scores if self.tie_breaker_activated else None
        for voting_rule in keys:
            if voting_rule in VotingRulesConstants.ONE_ROUND:
                result = sort_cand_by_value(self.candidates, voting_rule, duels=duels)
                self.results[voting_rule] = result

            if voting_rule in VotingRulesConstants.MULTI_ROUND:
                self.results[voting_rule] = [None] * len(candidate.scores[voting_rule])

                for round in range(len(candidate.scores[voting_rule])):
                    result = sort_cand_by_round(
                        self.candidates, voting_rule, round, duels=duels
                    )
                    self.results[voting_rule][round] = result

            if voting_rule in VotingRulesConstants.CONDORCET:
                sort_asc = (
                    True
                    if voting_rule == VotingRulesConstants.CONDORCET_SIMPSON
                    else False
                )
                result = sort_cand_by_value(self.candidates, voting_rule, duels=None, scores_asc=sort_asc)
                self.results[voting_rule] = result

    def start_election(self, imported: Optional[bool] = False, chosen_voting_rules: List[str] = None) -&gt; None:
        &#34;&#34;&#34;Commencer une élection. Faire toutes les calculs nécessaires:

        - Chaque électeur définit son classement des candidats
        - MAJ de la position moyenne des électeurs
        - Calculer le taux d&#39;une satisfaction
        - Si les sondages sont activées, MAJ des données pour chaque direction de la carte politique
        - Si la démocratie liquide est activée, faire les délégations.
        - Initialiser un dictionnaire `results` avec des règles du vote choisies.
        - Calculer des résultats.

        Args:
            imported (Optional[bool]): True si les données ont été importées, sinon False.
                Cf. `calc_results() &lt;electoral_systems.election.Election.calc_results&gt;`
            chosen_voting_rules (Set[str]): Une liste des constantes des règles du vote choisies.
        &#34;&#34;&#34;

        self._define_ranking()
        self.set_avg_electors_position()
        self._calc_proportion_satisfaction()

        # Set data for polls
        if self.nb_polls:
            set_avg_electors_positions(self.directions_data)
            set_std_deviation(self.directions_data, len(self.electors))
        if self.liquid_democracy_activated:
            self._make_delegations()
        if chosen_voting_rules:
            self._init_results_keys(chosen_voting_rules)

        self.calc_results(imported)

    def _make_delegations(self) -&gt; None:
        &#34;&#34;&#34;Pour une démocratie liquide. Pour chaque électeur décide s&#39;il fera une délégation de son vote.
        Si oui, MAJ des données de son délégataire et de lui-même.&#34;&#34;&#34;

        for elector in self.electors:
            proba = 1 - elector.knowledge
            # Pas de délégation
            if random() &gt; proba:
                continue
            # Faire une délégation
            possible_delegees = choose_possible_delegees(
                self.electors, elector
            )
            delegee = choose_delegee(possible_delegees)
            if delegee is None:
                continue
            delegee.weight += elector.weight
            elector.weight = 0

    def conduct_poll(self) -&gt; None:
        &#34;&#34;&#34;Faire une nouvelle sondage. Tout d&#39;abord les candidats changent ses positions. Les électeurs 
        redéfinissent leur classement des candidats. Après les électeurs changent son classement.
        Cf. polls &lt;electoral_systems.extensions.polls&gt; pour les détails.&#34;&#34;&#34;

        voting_rule = self.poll_voting_rule
        winner = self.choose_winner(voting_rule)
        ranking = self.results[voting_rule]

        # Des candidats changent leurs positions politiques
        change_position_candidates(
            self.candidates,
            winner,
            ranking,
            self.directions_data,
            self.generation_constants[RandomConstants.TRAVEL_DIST],
        )

        # Des électeurs changent leur classement
        self._define_ranking()

        # Des électeurs s&#39;adaptent en changeant leur classement intelligemment
        score_winner = winner.scores[voting_rule]
        change_ranking_electors(
            self.electors,
            score_winner,
            voting_rule,
            VotingRulesConstants.APPROVAL_GAP_COEF,
        )
        # Recalculer des résultats
        self.calc_results()

    def delete_all_data(self) -&gt; None:
        &#34;&#34;&#34;Supprimer toutes les données d&#39;une élection. Recommencer des itérateurs-générateurs des noms, prénoms, IDs.&#34;&#34;&#34;
        self.electors.clear()
        self.candidates.clear()
        self.results.clear()

        self.first_name_iter.restart()
        self.last_name_iter.restart()
        self.id_iter.restart()

        self.directions_data.clear()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tzb.electoral_systems.election.random"><code class="name flex">
<span>def <span class="ident">random</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>random() -&gt; x in the interval [0, 1).</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tzb.electoral_systems.election.Election"><code class="flex name class">
<span>class <span class="ident">Election</span></span>
</code></dt>
<dd>
<div class="desc"><p>Une classe Singleton qui contient toutes les données nécessaires pour une élection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Election(metaclass=Singleton):
    &#34;&#34;&#34;Une classe Singleton qui contient toutes les données nécessaires pour une élection.&#34;&#34;&#34;

    def __init__(self):
        super().__init__()
        self.electors = []
        self.candidates = []

        # Générer les prénoms, les noms
        self.first_name_iter = NameIterator()
        self.last_name_iter = NameIterator()

        # Générer les IDs
        self.id_iter = IdIterator(0)

        # Stocker des resultats
        self.results = dict()
        # Stocker des duels
        self.duels_scores = dict()

        # Pour satisfaction
        self.average_position_electors = (0, 0)
        self.proportion_satisfaction = 0

        # Init constantes
        self.set_default_settings()

    def set_default_settings(self) -&gt; None:
        &#34;&#34;&#34;Initialiser des réglages par défaut&#34;&#34;&#34;

        # Nb des sondages à faire
        self.nb_polls = 0

        # Activer/désactiver une démocratie liquide
        self.liquid_democracy_activated = False

        # Une règle du vote pour des sondages
        self.poll_voting_rule = VotingRulesConstants.PLURALITY_SIMPLE

        # Activer/désactiver un tie-break selon les duels
        self.tie_breaker_activated = True

        # Des constantes de la génération des données
        self.generation_constants = dict()
        for type, default_value in RandomConstants.DEFAULT_VALUES.items():
            self.generation_constants[type] = default_value

        # Pour sondages uniquement. Stocker les données pour chaque direction (division) de la carte politique
        self.directions_data = get_default_directions_data()

    def _init_results_keys(self, set_keys: Set[str]) -&gt; None:
        &#34;&#34;&#34;Initialiser des clés du dictionnaire `results` avec des constantes associées aux règles du vote choisies.
        Les valeurs sont rémies à `None`.
        &#34;&#34;&#34;

        for key in set_keys:
            self.results[key] = None

    def _calc_distance(self, point1: tuple[float, float], point2: tuple[float, float]) -&gt; float:
        &#34;&#34;&#34;Calculer la distance euclidienne entre 2 points.

        Args:
            point1 (tuple[float, float]): position sur la carte politique
            point2 (tuple[float, float]): position sur la carte politique
        Returns:
            float: Une distance euclidienne entre 2 points.
        &#34;&#34;&#34;
        x1, y1 = point1
        x2, y2 = point2
        return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)

    def has_electors_candidates(self) -&gt; bool:
        &#34;&#34;&#34;Vérifier qu&#39;il existe au moins un électeur et un candidat dans une élection.

        Returns:
            bool: True ssi il existe au moins un électeur et un candidat dans une élection, sinon False.
        &#34;&#34;&#34;
        if not self.electors and not self.candidates:
            return False
        return True

    def add_elector_import(self, new_elector: Elector) -&gt; None:
        &#34;&#34;&#34;Ajouter un électeur déjà dont les données déjà sont initialisées.
        Si les sondages sont activées, MAJ les données sur les directions de la carte politique.
        MAJ des données sur la position moyenne de tous les électeurs participand dans une élection.
        Utilisée lors d&#39;une importation des données.

        Args:
            new_elector (people.elector.Elector): Un nouveau électeur.
        &#34;&#34;&#34;

        if self.nb_polls:
            add_elector_data(self.directions_data, new_elector)

        x, y = new_elector.position
        x_avg, y_avg = self.average_position_electors
        x_avg, y_avg = x_avg + x, y_avg + y
        self.average_position_electors = (x_avg, y_avg)

        self.electors.append(new_elector)

    def add_elector(self, position: tuple[float, float]) -&gt; None:
        &#34;&#34;&#34;Ajouter un nouveau électeur dans une élection avec la position `position`.
        Si les sondages sont activées, MAJ les données sur les directions de la carte politique.
        MAJ des données sur la position moyenne de tous les électeurs participand dans une élection.

        Args:
            position (tuple[float, float]): Une position d&#39;un électeur sur la carte politique.
                Chaque coordonnée doit être borné entre -1 et 1.
        &#34;&#34;&#34;

        knowledge_const = self.generation_constants[RandomConstants.KNOWLEDGE]
        new_elector = Elector(
            id=next(self.id_iter), position=position, knowledge_const=knowledge_const
        )
        x, y = new_elector.position

        if self.nb_polls:
            add_elector_data(self.directions_data, new_elector)

        # All electors average
        x_avg, y_avg = self.average_position_electors
        x_avg, y_avg = x_avg + x, y_avg + y
        self.average_position_electors = (x_avg, y_avg)
        self.electors.append(new_elector)

    def add_candidate_import(self, new_candidate: Candidate) -&gt; None:
        &#34;&#34;&#34;Ajouter un candidat déjà dont les données déjà sont initialisées.
        Si les sondages sont activées, MAJ les données sur les directions de la carte politique.
        Utilisée lors d&#39;une importation des données.

        Args:
            new_elector (people.elector.Elector): un nouveau électeur.
        &#34;&#34;&#34;

        self.candidates.append(new_candidate)
        if self.nb_polls:
            add_candidate_data(self.directions_data, new_candidate)

    def add_candidate(self, position: tuple[float, float], first_name: Optional[str] = &#34;&#34;, last_name: Optional[str] = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;Ajouter un nouveau candidat dans une élection avec la position `position`, et éventuellement
        le prénom et le nom.
        Si les sondages sont activées, MAJ les données sur les directions de la carte politique.

        Args:
            position (tuple[float, float]): Une position d&#39;un candidat sur la carte politique.
                Chaque coordonnée doit être borné entre -1 et 1.
            first_name (Optional[str]): Un prénom d&#39;un candidat.
            last_name (Optional[str]): Un nom d&#39;un candidat.
        &#34;&#34;&#34;

        dogmat_const = self.generation_constants[RandomConstants.DOGMATISM]
        oppos_const = self.generation_constants[RandomConstants.OPPOSITION]

        first_name = next(self.first_name_iter) if not first_name else first_name
        last_name = next(self.last_name_iter) if not last_name else last_name

        new_candidate = Candidate(
            id=next(self.id_iter),
            position=position,
            first_name=first_name,
            last_name=last_name,
            dogmatism_const=dogmat_const,
            opposition_const=oppos_const,
        )
        if self.nb_polls:
            add_candidate_data(self.directions_data, new_candidate)

        self.candidates.append(new_candidate)

    def apply_voting_rule(self, voting_rule: str) -&gt; None:
        &#34;&#34;&#34;Appliquer une règle du vote `voting_rule`. Remplir une case correspondante à `voting_rule` du dictionnaire `results`
        avec une liste (un classement) des candidats. La fonction est appliquée uniquement s&#39;il existe au moins un électeur
        et un candidate, sinon elle fait rien.

        Args:
            voting_rule (str): Une constante correspondante à une règle du vote.
        &#34;&#34;&#34;

        if not self.has_electors_candidates():
            return

        result = []
        func = VotingRulesConstants.VOTING_RULES_FUNC[voting_rule]

        if voting_rule in VotingRulesConstants.CONDORCET:
            result = func(self.electors, self.candidates, self.duels_scores)

        elif voting_rule == VotingRulesConstants.APPROVAL:
            result = func(
                self.electors,
                self.candidates,
                VotingRulesConstants.APPROVAL_GAP_COEF,
                self.duels_scores if self.tie_breaker_activated else None,
            )
        else:
            result = func(
                self.electors,
                self.candidates,
                self.duels_scores if self.tie_breaker_activated else None,
            )

        self.results[voting_rule] = result

    def choose_winner(self, voting_rule: str) -&gt; Union[Candidate, None]:
        &#34;&#34;&#34;Choisir un gagnant d&#39;une règle du vote `voting_rule` selon les règles.

        Args:
            voting_rule (str): Une constante correspondante à une règle du vote.

        Returns:
            Union[Candidate, None]: Un candidat-gagnant. Peut retourner `None` dans un condorcet simple ou
                si le classement associé à `voting_rule` est vide.
        &#34;&#34;&#34;
        if voting_rule not in self.results:
            self.apply_voting_rule(voting_rule)

        if not len(self.results[voting_rule]):
            return None

        if voting_rule in VotingRulesConstants.MULTI_ROUND:
            return self.results[voting_rule][-1][0]

        if voting_rule == VotingRulesConstants.CONDORCET_SIMPLE:
            return self.choose_condorcet_winner()

        return self.results[voting_rule][0]

    def choose_condorcet_winner(self) -&gt; Union[Candidate, None]:
        &#34;&#34;&#34;Choisir un gagnant dans une règle du vote Condorcet simple. Un gagnant est un candidat que bat
        tous les autres candidats dans les duels.

        Returns:
            Union[Candidate, None]: Un candidat du Condorcet s&#39;il existe, sinon None.
        &#34;&#34;&#34;

        fst_candidate = self.results[VotingRulesConstants.CONDORCET_SIMPLE][0]
        score = fst_candidate.scores[VotingRulesConstants.CONDORCET_SIMPLE]
        return fst_candidate if score == len(self.candidates) - 1 else None

    def _define_ranking(self) -&gt; None:
        &#34;&#34;&#34;Faire chaque electeur classer des candidats. Doit être appelée uniquement quand tous les candidats ont été ajoutés.&#34;&#34;&#34;

        for elector in self.electors:
            elector.rank_candidates(self.candidates)

    def calc_results(self, imported: Optional[bool] = False) -&gt; None:
        &#34;&#34;&#34;Calculer des résultats d&#39;une élection, i.e. Calculer les duels entre les candidats, attribuer des scores aux candidats, 
        et calculer des classements des candidats dans chaque règle du vote choisie.

        Args:
            imported (bool): True si les données one été importés. Si oui, ne pas calculer des duels et des scores des candidats
                dans chaque règle du vote choisie. Ils sont importés. Cepedant, un calcul des classement est effectué.
        &#34;&#34;&#34;

        if imported:
            # Duels sont importés dans sqlite.ImportData
            self.set_results()
            return

        self.duels_scores = set_duels_scores(self.electors, self.candidates)
        for voting_rule in self.results:
            self.apply_voting_rule(voting_rule)

    def set_avg_electors_position(self) -&gt; None:
        &#34;&#34;&#34;Calculer une position moyenne des électeurs. Uniquement la division est faite. La somme de toutes les positions
        est déjà stockée.&#34;&#34;&#34;

        x_avg, y_avg = self.average_position_electors
        x_avg /= len(self.electors)
        y_avg /= len(self.electors)
        self.average_position_electors = (x_avg, y_avg)

    def _calc_proportion_satisfaction(self) -&gt; None:
        &#34;&#34;&#34;Calculer le taux d&#39;une satisfaction de la population.&#34;&#34;&#34;

        proportion = 0
        for candidate in self.candidates:
            dist_cand_electors = self._calc_distance(
                candidate.position, self.average_position_electors
            )
            proportion = max(proportion, dist_cand_electors)
        self.proportion_satisfaction = proportion

    def calc_satisfaction(self, candidate: Candidate) -&gt; float:
        &#34;&#34;&#34;Calculer le pourcentage de la population qui est satisfait par une victoire du candidat `candidate` dans une élection.

        Args:
            candidate (people.candidate.Candidate): Un candidat-gagnant.

        Returns:
            float: Le pourcentage de la population.
        &#34;&#34;&#34;
        diff = abs(
            self._calc_distance(candidate.position, self.average_position_electors)
            - self.proportion_satisfaction
        )
        percentage = (
            diff / self.proportion_satisfaction * 100
            if self.proportion_satisfaction != 0
            else 0
        )
        return percentage

    def set_results(self) -&gt; None:
        &#34;&#34;&#34;Calculer un classement des candidats selon leurs scores (les scores sont déjà attribués à chaque candidat).
        Utilisée lors de l&#39;importation des données. MAJ d&#39;un dictionnaire `results`. La fonction fait rien s&#39;il n&#39;existe pas 
        au moins un électeur et un candidat.
        &#34;&#34;&#34;

        if not self.has_electors_candidates():
            return
        # Assuming every candidate has the same voting_rules
        candidate = self.candidates[0]
        keys = candidate.scores.keys()

        duels = self.duels_scores if self.tie_breaker_activated else None
        for voting_rule in keys:
            if voting_rule in VotingRulesConstants.ONE_ROUND:
                result = sort_cand_by_value(self.candidates, voting_rule, duels=duels)
                self.results[voting_rule] = result

            if voting_rule in VotingRulesConstants.MULTI_ROUND:
                self.results[voting_rule] = [None] * len(candidate.scores[voting_rule])

                for round in range(len(candidate.scores[voting_rule])):
                    result = sort_cand_by_round(
                        self.candidates, voting_rule, round, duels=duels
                    )
                    self.results[voting_rule][round] = result

            if voting_rule in VotingRulesConstants.CONDORCET:
                sort_asc = (
                    True
                    if voting_rule == VotingRulesConstants.CONDORCET_SIMPSON
                    else False
                )
                result = sort_cand_by_value(self.candidates, voting_rule, duels=None, scores_asc=sort_asc)
                self.results[voting_rule] = result

    def start_election(self, imported: Optional[bool] = False, chosen_voting_rules: List[str] = None) -&gt; None:
        &#34;&#34;&#34;Commencer une élection. Faire toutes les calculs nécessaires:

        - Chaque électeur définit son classement des candidats
        - MAJ de la position moyenne des électeurs
        - Calculer le taux d&#39;une satisfaction
        - Si les sondages sont activées, MAJ des données pour chaque direction de la carte politique
        - Si la démocratie liquide est activée, faire les délégations.
        - Initialiser un dictionnaire `results` avec des règles du vote choisies.
        - Calculer des résultats.

        Args:
            imported (Optional[bool]): True si les données ont été importées, sinon False.
                Cf. `calc_results() &lt;electoral_systems.election.Election.calc_results&gt;`
            chosen_voting_rules (Set[str]): Une liste des constantes des règles du vote choisies.
        &#34;&#34;&#34;

        self._define_ranking()
        self.set_avg_electors_position()
        self._calc_proportion_satisfaction()

        # Set data for polls
        if self.nb_polls:
            set_avg_electors_positions(self.directions_data)
            set_std_deviation(self.directions_data, len(self.electors))
        if self.liquid_democracy_activated:
            self._make_delegations()
        if chosen_voting_rules:
            self._init_results_keys(chosen_voting_rules)

        self.calc_results(imported)

    def _make_delegations(self) -&gt; None:
        &#34;&#34;&#34;Pour une démocratie liquide. Pour chaque électeur décide s&#39;il fera une délégation de son vote.
        Si oui, MAJ des données de son délégataire et de lui-même.&#34;&#34;&#34;

        for elector in self.electors:
            proba = 1 - elector.knowledge
            # Pas de délégation
            if random() &gt; proba:
                continue
            # Faire une délégation
            possible_delegees = choose_possible_delegees(
                self.electors, elector
            )
            delegee = choose_delegee(possible_delegees)
            if delegee is None:
                continue
            delegee.weight += elector.weight
            elector.weight = 0

    def conduct_poll(self) -&gt; None:
        &#34;&#34;&#34;Faire une nouvelle sondage. Tout d&#39;abord les candidats changent ses positions. Les électeurs 
        redéfinissent leur classement des candidats. Après les électeurs changent son classement.
        Cf. polls &lt;electoral_systems.extensions.polls&gt; pour les détails.&#34;&#34;&#34;

        voting_rule = self.poll_voting_rule
        winner = self.choose_winner(voting_rule)
        ranking = self.results[voting_rule]

        # Des candidats changent leurs positions politiques
        change_position_candidates(
            self.candidates,
            winner,
            ranking,
            self.directions_data,
            self.generation_constants[RandomConstants.TRAVEL_DIST],
        )

        # Des électeurs changent leur classement
        self._define_ranking()

        # Des électeurs s&#39;adaptent en changeant leur classement intelligemment
        score_winner = winner.scores[voting_rule]
        change_ranking_electors(
            self.electors,
            score_winner,
            voting_rule,
            VotingRulesConstants.APPROVAL_GAP_COEF,
        )
        # Recalculer des résultats
        self.calc_results()

    def delete_all_data(self) -&gt; None:
        &#34;&#34;&#34;Supprimer toutes les données d&#39;une élection. Recommencer des itérateurs-générateurs des noms, prénoms, IDs.&#34;&#34;&#34;
        self.electors.clear()
        self.candidates.clear()
        self.results.clear()

        self.first_name_iter.restart()
        self.last_name_iter.restart()
        self.id_iter.restart()

        self.directions_data.clear()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tzb.electoral_systems.election.Election.add_candidate"><code class="name flex">
<span>def <span class="ident">add_candidate</span></span>(<span>self, position: tuple[float, float], first_name: Optional[str] = '', last_name: Optional[str] = '') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Ajouter un nouveau candidat dans une élection avec la position <code>position</code>, et éventuellement
le prénom et le nom.
Si les sondages sont activées, MAJ les données sur les directions de la carte politique.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>tuple[float, float]</code></dt>
<dd>Une position d'un candidat sur la carte politique.
Chaque coordonnée doit être borné entre -1 et 1.</dd>
<dt><strong><code>first_name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Un prénom d'un candidat.</dd>
<dt><strong><code>last_name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Un nom d'un candidat.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_candidate(self, position: tuple[float, float], first_name: Optional[str] = &#34;&#34;, last_name: Optional[str] = &#34;&#34;) -&gt; None:
    &#34;&#34;&#34;Ajouter un nouveau candidat dans une élection avec la position `position`, et éventuellement
    le prénom et le nom.
    Si les sondages sont activées, MAJ les données sur les directions de la carte politique.

    Args:
        position (tuple[float, float]): Une position d&#39;un candidat sur la carte politique.
            Chaque coordonnée doit être borné entre -1 et 1.
        first_name (Optional[str]): Un prénom d&#39;un candidat.
        last_name (Optional[str]): Un nom d&#39;un candidat.
    &#34;&#34;&#34;

    dogmat_const = self.generation_constants[RandomConstants.DOGMATISM]
    oppos_const = self.generation_constants[RandomConstants.OPPOSITION]

    first_name = next(self.first_name_iter) if not first_name else first_name
    last_name = next(self.last_name_iter) if not last_name else last_name

    new_candidate = Candidate(
        id=next(self.id_iter),
        position=position,
        first_name=first_name,
        last_name=last_name,
        dogmatism_const=dogmat_const,
        opposition_const=oppos_const,
    )
    if self.nb_polls:
        add_candidate_data(self.directions_data, new_candidate)

    self.candidates.append(new_candidate)</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.add_candidate_import"><code class="name flex">
<span>def <span class="ident">add_candidate_import</span></span>(<span>self, new_candidate: people.candidate.Candidate) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Ajouter un candidat déjà dont les données déjà sont initialisées.
Si les sondages sont activées, MAJ les données sur les directions de la carte politique.
Utilisée lors d'une importation des données.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_elector</code></strong> :&ensp;<code>people.elector.Elector</code></dt>
<dd>un nouveau électeur.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_candidate_import(self, new_candidate: Candidate) -&gt; None:
    &#34;&#34;&#34;Ajouter un candidat déjà dont les données déjà sont initialisées.
    Si les sondages sont activées, MAJ les données sur les directions de la carte politique.
    Utilisée lors d&#39;une importation des données.

    Args:
        new_elector (people.elector.Elector): un nouveau électeur.
    &#34;&#34;&#34;

    self.candidates.append(new_candidate)
    if self.nb_polls:
        add_candidate_data(self.directions_data, new_candidate)</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.add_elector"><code class="name flex">
<span>def <span class="ident">add_elector</span></span>(<span>self, position: tuple[float, float]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Ajouter un nouveau électeur dans une élection avec la position <code>position</code>.
Si les sondages sont activées, MAJ les données sur les directions de la carte politique.
MAJ des données sur la position moyenne de tous les électeurs participand dans une élection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>tuple[float, float]</code></dt>
<dd>Une position d'un électeur sur la carte politique.
Chaque coordonnée doit être borné entre -1 et 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_elector(self, position: tuple[float, float]) -&gt; None:
    &#34;&#34;&#34;Ajouter un nouveau électeur dans une élection avec la position `position`.
    Si les sondages sont activées, MAJ les données sur les directions de la carte politique.
    MAJ des données sur la position moyenne de tous les électeurs participand dans une élection.

    Args:
        position (tuple[float, float]): Une position d&#39;un électeur sur la carte politique.
            Chaque coordonnée doit être borné entre -1 et 1.
    &#34;&#34;&#34;

    knowledge_const = self.generation_constants[RandomConstants.KNOWLEDGE]
    new_elector = Elector(
        id=next(self.id_iter), position=position, knowledge_const=knowledge_const
    )
    x, y = new_elector.position

    if self.nb_polls:
        add_elector_data(self.directions_data, new_elector)

    # All electors average
    x_avg, y_avg = self.average_position_electors
    x_avg, y_avg = x_avg + x, y_avg + y
    self.average_position_electors = (x_avg, y_avg)
    self.electors.append(new_elector)</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.add_elector_import"><code class="name flex">
<span>def <span class="ident">add_elector_import</span></span>(<span>self, new_elector: people.elector.Elector) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Ajouter un électeur déjà dont les données déjà sont initialisées.
Si les sondages sont activées, MAJ les données sur les directions de la carte politique.
MAJ des données sur la position moyenne de tous les électeurs participand dans une élection.
Utilisée lors d'une importation des données.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_elector</code></strong> :&ensp;<code>people.elector.Elector</code></dt>
<dd>Un nouveau électeur.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_elector_import(self, new_elector: Elector) -&gt; None:
    &#34;&#34;&#34;Ajouter un électeur déjà dont les données déjà sont initialisées.
    Si les sondages sont activées, MAJ les données sur les directions de la carte politique.
    MAJ des données sur la position moyenne de tous les électeurs participand dans une élection.
    Utilisée lors d&#39;une importation des données.

    Args:
        new_elector (people.elector.Elector): Un nouveau électeur.
    &#34;&#34;&#34;

    if self.nb_polls:
        add_elector_data(self.directions_data, new_elector)

    x, y = new_elector.position
    x_avg, y_avg = self.average_position_electors
    x_avg, y_avg = x_avg + x, y_avg + y
    self.average_position_electors = (x_avg, y_avg)

    self.electors.append(new_elector)</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.apply_voting_rule"><code class="name flex">
<span>def <span class="ident">apply_voting_rule</span></span>(<span>self, voting_rule: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Appliquer une règle du vote <code>voting_rule</code>. Remplir une case correspondante à <code>voting_rule</code> du dictionnaire <code>results</code>
avec une liste (un classement) des candidats. La fonction est appliquée uniquement s'il existe au moins un électeur
et un candidate, sinon elle fait rien.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voting_rule</code></strong> :&ensp;<code>str</code></dt>
<dd>Une constante correspondante à une règle du vote.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_voting_rule(self, voting_rule: str) -&gt; None:
    &#34;&#34;&#34;Appliquer une règle du vote `voting_rule`. Remplir une case correspondante à `voting_rule` du dictionnaire `results`
    avec une liste (un classement) des candidats. La fonction est appliquée uniquement s&#39;il existe au moins un électeur
    et un candidate, sinon elle fait rien.

    Args:
        voting_rule (str): Une constante correspondante à une règle du vote.
    &#34;&#34;&#34;

    if not self.has_electors_candidates():
        return

    result = []
    func = VotingRulesConstants.VOTING_RULES_FUNC[voting_rule]

    if voting_rule in VotingRulesConstants.CONDORCET:
        result = func(self.electors, self.candidates, self.duels_scores)

    elif voting_rule == VotingRulesConstants.APPROVAL:
        result = func(
            self.electors,
            self.candidates,
            VotingRulesConstants.APPROVAL_GAP_COEF,
            self.duels_scores if self.tie_breaker_activated else None,
        )
    else:
        result = func(
            self.electors,
            self.candidates,
            self.duels_scores if self.tie_breaker_activated else None,
        )

    self.results[voting_rule] = result</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.calc_results"><code class="name flex">
<span>def <span class="ident">calc_results</span></span>(<span>self, imported: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calculer des résultats d'une élection, i.e. Calculer les duels entre les candidats, attribuer des scores aux candidats,
et calculer des classements des candidats dans chaque règle du vote choisie.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>imported</code></strong> :&ensp;<code>bool</code></dt>
<dd>True si les données one été importés. Si oui, ne pas calculer des duels et des scores des candidats
dans chaque règle du vote choisie. Ils sont importés. Cepedant, un calcul des classement est effectué.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_results(self, imported: Optional[bool] = False) -&gt; None:
    &#34;&#34;&#34;Calculer des résultats d&#39;une élection, i.e. Calculer les duels entre les candidats, attribuer des scores aux candidats, 
    et calculer des classements des candidats dans chaque règle du vote choisie.

    Args:
        imported (bool): True si les données one été importés. Si oui, ne pas calculer des duels et des scores des candidats
            dans chaque règle du vote choisie. Ils sont importés. Cepedant, un calcul des classement est effectué.
    &#34;&#34;&#34;

    if imported:
        # Duels sont importés dans sqlite.ImportData
        self.set_results()
        return

    self.duels_scores = set_duels_scores(self.electors, self.candidates)
    for voting_rule in self.results:
        self.apply_voting_rule(voting_rule)</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.calc_satisfaction"><code class="name flex">
<span>def <span class="ident">calc_satisfaction</span></span>(<span>self, candidate: people.candidate.Candidate) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculer le pourcentage de la population qui est satisfait par une victoire du candidat <code>candidate</code> dans une élection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>candidate</code></strong> :&ensp;<code>people.candidate.Candidate</code></dt>
<dd>Un candidat-gagnant.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Le pourcentage de la population.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_satisfaction(self, candidate: Candidate) -&gt; float:
    &#34;&#34;&#34;Calculer le pourcentage de la population qui est satisfait par une victoire du candidat `candidate` dans une élection.

    Args:
        candidate (people.candidate.Candidate): Un candidat-gagnant.

    Returns:
        float: Le pourcentage de la population.
    &#34;&#34;&#34;
    diff = abs(
        self._calc_distance(candidate.position, self.average_position_electors)
        - self.proportion_satisfaction
    )
    percentage = (
        diff / self.proportion_satisfaction * 100
        if self.proportion_satisfaction != 0
        else 0
    )
    return percentage</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.choose_condorcet_winner"><code class="name flex">
<span>def <span class="ident">choose_condorcet_winner</span></span>(<span>self) ‑> Optional[people.candidate.Candidate]</span>
</code></dt>
<dd>
<div class="desc"><p>Choisir un gagnant dans une règle du vote Condorcet simple. Un gagnant est un candidat que bat
tous les autres candidats dans les duels.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[Candidate, None]</code></dt>
<dd>Un candidat du Condorcet s'il existe, sinon None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_condorcet_winner(self) -&gt; Union[Candidate, None]:
    &#34;&#34;&#34;Choisir un gagnant dans une règle du vote Condorcet simple. Un gagnant est un candidat que bat
    tous les autres candidats dans les duels.

    Returns:
        Union[Candidate, None]: Un candidat du Condorcet s&#39;il existe, sinon None.
    &#34;&#34;&#34;

    fst_candidate = self.results[VotingRulesConstants.CONDORCET_SIMPLE][0]
    score = fst_candidate.scores[VotingRulesConstants.CONDORCET_SIMPLE]
    return fst_candidate if score == len(self.candidates) - 1 else None</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.choose_winner"><code class="name flex">
<span>def <span class="ident">choose_winner</span></span>(<span>self, voting_rule: str) ‑> Optional[people.candidate.Candidate]</span>
</code></dt>
<dd>
<div class="desc"><p>Choisir un gagnant d'une règle du vote <code>voting_rule</code> selon les règles.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voting_rule</code></strong> :&ensp;<code>str</code></dt>
<dd>Une constante correspondante à une règle du vote.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[Candidate, None]</code></dt>
<dd>Un candidat-gagnant. Peut retourner <code>None</code> dans un condorcet simple ou
si le classement associé à <code>voting_rule</code> est vide.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_winner(self, voting_rule: str) -&gt; Union[Candidate, None]:
    &#34;&#34;&#34;Choisir un gagnant d&#39;une règle du vote `voting_rule` selon les règles.

    Args:
        voting_rule (str): Une constante correspondante à une règle du vote.

    Returns:
        Union[Candidate, None]: Un candidat-gagnant. Peut retourner `None` dans un condorcet simple ou
            si le classement associé à `voting_rule` est vide.
    &#34;&#34;&#34;
    if voting_rule not in self.results:
        self.apply_voting_rule(voting_rule)

    if not len(self.results[voting_rule]):
        return None

    if voting_rule in VotingRulesConstants.MULTI_ROUND:
        return self.results[voting_rule][-1][0]

    if voting_rule == VotingRulesConstants.CONDORCET_SIMPLE:
        return self.choose_condorcet_winner()

    return self.results[voting_rule][0]</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.conduct_poll"><code class="name flex">
<span>def <span class="ident">conduct_poll</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Faire une nouvelle sondage. Tout d'abord les candidats changent ses positions. Les électeurs
redéfinissent leur classement des candidats. Après les électeurs changent son classement.
Cf. polls <electoral_systems.extensions.polls> pour les détails.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conduct_poll(self) -&gt; None:
    &#34;&#34;&#34;Faire une nouvelle sondage. Tout d&#39;abord les candidats changent ses positions. Les électeurs 
    redéfinissent leur classement des candidats. Après les électeurs changent son classement.
    Cf. polls &lt;electoral_systems.extensions.polls&gt; pour les détails.&#34;&#34;&#34;

    voting_rule = self.poll_voting_rule
    winner = self.choose_winner(voting_rule)
    ranking = self.results[voting_rule]

    # Des candidats changent leurs positions politiques
    change_position_candidates(
        self.candidates,
        winner,
        ranking,
        self.directions_data,
        self.generation_constants[RandomConstants.TRAVEL_DIST],
    )

    # Des électeurs changent leur classement
    self._define_ranking()

    # Des électeurs s&#39;adaptent en changeant leur classement intelligemment
    score_winner = winner.scores[voting_rule]
    change_ranking_electors(
        self.electors,
        score_winner,
        voting_rule,
        VotingRulesConstants.APPROVAL_GAP_COEF,
    )
    # Recalculer des résultats
    self.calc_results()</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.delete_all_data"><code class="name flex">
<span>def <span class="ident">delete_all_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Supprimer toutes les données d'une élection. Recommencer des itérateurs-générateurs des noms, prénoms, IDs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_all_data(self) -&gt; None:
    &#34;&#34;&#34;Supprimer toutes les données d&#39;une élection. Recommencer des itérateurs-générateurs des noms, prénoms, IDs.&#34;&#34;&#34;
    self.electors.clear()
    self.candidates.clear()
    self.results.clear()

    self.first_name_iter.restart()
    self.last_name_iter.restart()
    self.id_iter.restart()

    self.directions_data.clear()</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.has_electors_candidates"><code class="name flex">
<span>def <span class="ident">has_electors_candidates</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Vérifier qu'il existe au moins un électeur et un candidat dans une élection.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True ssi il existe au moins un électeur et un candidat dans une élection, sinon False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_electors_candidates(self) -&gt; bool:
    &#34;&#34;&#34;Vérifier qu&#39;il existe au moins un électeur et un candidat dans une élection.

    Returns:
        bool: True ssi il existe au moins un électeur et un candidat dans une élection, sinon False.
    &#34;&#34;&#34;
    if not self.electors and not self.candidates:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.set_avg_electors_position"><code class="name flex">
<span>def <span class="ident">set_avg_electors_position</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calculer une position moyenne des électeurs. Uniquement la division est faite. La somme de toutes les positions
est déjà stockée.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_avg_electors_position(self) -&gt; None:
    &#34;&#34;&#34;Calculer une position moyenne des électeurs. Uniquement la division est faite. La somme de toutes les positions
    est déjà stockée.&#34;&#34;&#34;

    x_avg, y_avg = self.average_position_electors
    x_avg /= len(self.electors)
    y_avg /= len(self.electors)
    self.average_position_electors = (x_avg, y_avg)</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.set_default_settings"><code class="name flex">
<span>def <span class="ident">set_default_settings</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialiser des réglages par défaut</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_settings(self) -&gt; None:
    &#34;&#34;&#34;Initialiser des réglages par défaut&#34;&#34;&#34;

    # Nb des sondages à faire
    self.nb_polls = 0

    # Activer/désactiver une démocratie liquide
    self.liquid_democracy_activated = False

    # Une règle du vote pour des sondages
    self.poll_voting_rule = VotingRulesConstants.PLURALITY_SIMPLE

    # Activer/désactiver un tie-break selon les duels
    self.tie_breaker_activated = True

    # Des constantes de la génération des données
    self.generation_constants = dict()
    for type, default_value in RandomConstants.DEFAULT_VALUES.items():
        self.generation_constants[type] = default_value

    # Pour sondages uniquement. Stocker les données pour chaque direction (division) de la carte politique
    self.directions_data = get_default_directions_data()</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.set_results"><code class="name flex">
<span>def <span class="ident">set_results</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calculer un classement des candidats selon leurs scores (les scores sont déjà attribués à chaque candidat).
Utilisée lors de l'importation des données. MAJ d'un dictionnaire <code>results</code>. La fonction fait rien s'il n'existe pas
au moins un électeur et un candidat.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_results(self) -&gt; None:
    &#34;&#34;&#34;Calculer un classement des candidats selon leurs scores (les scores sont déjà attribués à chaque candidat).
    Utilisée lors de l&#39;importation des données. MAJ d&#39;un dictionnaire `results`. La fonction fait rien s&#39;il n&#39;existe pas 
    au moins un électeur et un candidat.
    &#34;&#34;&#34;

    if not self.has_electors_candidates():
        return
    # Assuming every candidate has the same voting_rules
    candidate = self.candidates[0]
    keys = candidate.scores.keys()

    duels = self.duels_scores if self.tie_breaker_activated else None
    for voting_rule in keys:
        if voting_rule in VotingRulesConstants.ONE_ROUND:
            result = sort_cand_by_value(self.candidates, voting_rule, duels=duels)
            self.results[voting_rule] = result

        if voting_rule in VotingRulesConstants.MULTI_ROUND:
            self.results[voting_rule] = [None] * len(candidate.scores[voting_rule])

            for round in range(len(candidate.scores[voting_rule])):
                result = sort_cand_by_round(
                    self.candidates, voting_rule, round, duels=duels
                )
                self.results[voting_rule][round] = result

        if voting_rule in VotingRulesConstants.CONDORCET:
            sort_asc = (
                True
                if voting_rule == VotingRulesConstants.CONDORCET_SIMPSON
                else False
            )
            result = sort_cand_by_value(self.candidates, voting_rule, duels=None, scores_asc=sort_asc)
            self.results[voting_rule] = result</code></pre>
</details>
</dd>
<dt id="tzb.electoral_systems.election.Election.start_election"><code class="name flex">
<span>def <span class="ident">start_election</span></span>(<span>self, imported: Optional[bool] = False, chosen_voting_rules: List[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Commencer une élection. Faire toutes les calculs nécessaires:</p>
<ul>
<li>Chaque électeur définit son classement des candidats</li>
<li>MAJ de la position moyenne des électeurs</li>
<li>Calculer le taux d'une satisfaction</li>
<li>Si les sondages sont activées, MAJ des données pour chaque direction de la carte politique</li>
<li>Si la démocratie liquide est activée, faire les délégations.</li>
<li>Initialiser un dictionnaire <code>results</code> avec des règles du vote choisies.</li>
<li>Calculer des résultats.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>imported</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>True si les données ont été importées, sinon False.
Cf. <code>calc_results() &lt;electoral_systems.election.Election.calc_results&gt;</code></dd>
<dt><strong><code>chosen_voting_rules</code></strong> :&ensp;<code>Set[str]</code></dt>
<dd>Une liste des constantes des règles du vote choisies.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_election(self, imported: Optional[bool] = False, chosen_voting_rules: List[str] = None) -&gt; None:
    &#34;&#34;&#34;Commencer une élection. Faire toutes les calculs nécessaires:

    - Chaque électeur définit son classement des candidats
    - MAJ de la position moyenne des électeurs
    - Calculer le taux d&#39;une satisfaction
    - Si les sondages sont activées, MAJ des données pour chaque direction de la carte politique
    - Si la démocratie liquide est activée, faire les délégations.
    - Initialiser un dictionnaire `results` avec des règles du vote choisies.
    - Calculer des résultats.

    Args:
        imported (Optional[bool]): True si les données ont été importées, sinon False.
            Cf. `calc_results() &lt;electoral_systems.election.Election.calc_results&gt;`
        chosen_voting_rules (Set[str]): Une liste des constantes des règles du vote choisies.
    &#34;&#34;&#34;

    self._define_ranking()
    self.set_avg_electors_position()
    self._calc_proportion_satisfaction()

    # Set data for polls
    if self.nb_polls:
        set_avg_electors_positions(self.directions_data)
        set_std_deviation(self.directions_data, len(self.electors))
    if self.liquid_democracy_activated:
        self._make_delegations()
    if chosen_voting_rules:
        self._init_results_keys(chosen_voting_rules)

    self.calc_results(imported)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tzb.electoral_systems" href="index.html">tzb.electoral_systems</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tzb.electoral_systems.election.random" href="#tzb.electoral_systems.election.random">random</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tzb.electoral_systems.election.Election" href="#tzb.electoral_systems.election.Election">Election</a></code></h4>
<ul class="">
<li><code><a title="tzb.electoral_systems.election.Election.add_candidate" href="#tzb.electoral_systems.election.Election.add_candidate">add_candidate</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.add_candidate_import" href="#tzb.electoral_systems.election.Election.add_candidate_import">add_candidate_import</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.add_elector" href="#tzb.electoral_systems.election.Election.add_elector">add_elector</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.add_elector_import" href="#tzb.electoral_systems.election.Election.add_elector_import">add_elector_import</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.apply_voting_rule" href="#tzb.electoral_systems.election.Election.apply_voting_rule">apply_voting_rule</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.calc_results" href="#tzb.electoral_systems.election.Election.calc_results">calc_results</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.calc_satisfaction" href="#tzb.electoral_systems.election.Election.calc_satisfaction">calc_satisfaction</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.choose_condorcet_winner" href="#tzb.electoral_systems.election.Election.choose_condorcet_winner">choose_condorcet_winner</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.choose_winner" href="#tzb.electoral_systems.election.Election.choose_winner">choose_winner</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.conduct_poll" href="#tzb.electoral_systems.election.Election.conduct_poll">conduct_poll</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.delete_all_data" href="#tzb.electoral_systems.election.Election.delete_all_data">delete_all_data</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.has_electors_candidates" href="#tzb.electoral_systems.election.Election.has_electors_candidates">has_electors_candidates</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.set_avg_electors_position" href="#tzb.electoral_systems.election.Election.set_avg_electors_position">set_avg_electors_position</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.set_default_settings" href="#tzb.electoral_systems.election.Election.set_default_settings">set_default_settings</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.set_results" href="#tzb.electoral_systems.election.Election.set_results">set_results</a></code></li>
<li><code><a title="tzb.electoral_systems.election.Election.start_election" href="#tzb.electoral_systems.election.Election.start_election">start_election</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>