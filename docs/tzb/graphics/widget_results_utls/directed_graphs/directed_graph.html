<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tzb.graphics.widget_results_utls.directed_graphs.directed_graph API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tzb.graphics.widget_results_utls.directed_graphs.directed_graph</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from math import sin, cos, pi, sqrt, atan2

from PySide6.QtWidgets import QGraphicsScene, QWidget
from PySide6.QtGui import QPainterPath, QColor
from PySide6.QtCore import QPointF, QSize

from .node import Node
from .edge import Edge

from electoral_systems import Election


class DirectedGraph(QGraphicsScene):
    &#34;&#34;&#34;Une scène sur laquelle un graphe orienté sera dessiné.&#34;&#34;&#34;

    def __init__(self, view_size: QSize, voting_rule: str, parent: QWidget):
        &#34;&#34;&#34;Initialiser une instance  d&#39;une élection (pour le partage des données). Fixer la taille.
        Définir le couleur de l&#39;arrière plan. Initialiser un `PySide6.QtGui.QPainterPath` pour les arêtes. 

        Args:
            view_size (PySide6.QtCore.QSize): La taille d&#39;un view associé.
            voting_rule (str): Une constante d&#39;une règle du vote dont les résultats une scène dessinera.
            parent (PySide6.QtWidgets.QWidget): Le parent d&#39;une scène.
        &#34;&#34;&#34;

        super().__init__(parent)
        self.election = Election()

        # Un dict sera rempli dans initNodes
        self.id_position = dict()

        self.view_size = view_size
        self.voting_rule = voting_rule
        self.path = QPainterPath()

        # Couleur gris-claire
        self.setBackgroundBrush(QColor(238, 238, 238))
        self.calculateCircle()

    def drawGraphics(self, weighted: bool) -&gt; None:
        &#34;&#34;&#34;Initialiser et placer des noeuds et des arêtes d&#39;un graphe orienté.

        Args:
            weighted (bool): True s&#39;il faut représenter des poids. Sinon, False.
        &#34;&#34;&#34;

        self.initNodes()
        self.initEdges(weighted)

    def initNodes(self) -&gt; None:
        &#34;&#34;&#34;Initialiser et placer des noeuds. Remplir un dictionnaire `id_position` qui associe un ID d&#39;un candidat
        et noeud d&#39;un candidat.&#34;&#34;&#34;

        # Dict key : ID d&#39;un candidat, value : son noeud associé
        winner = self.election.choose_winner(self.voting_rule)

        for i in range(len(self.election.candidates)):
            x = self.center.x() + self.radius * cos(self.angle * i)
            y = self.center.y() + self.radius * sin(self.angle * i)

            candidate = self.election.candidates[i]
            node = Node(x, y, f&#34;{candidate.first_name} {candidate.last_name}&#34;)

            if candidate == winner:
                node.highlight()

            self.id_position[candidate.id] = node
            self.addItem(node)

    # draw edges between nodes
    def initEdges(self, weighted: bool) -&gt; None:
        &#34;&#34;&#34;Initialiser et placer des arêtes d&#39;un graphe.

        Args:
            weighted (bool): True s&#39;il faut représenter des poids. Sinon, False.
        &#34;&#34;&#34;

        # Les duels des candidats déjà remplis
        for (winner, loser), weight in self.election.duels_scores.items():

            winner_node = self.id_position[winner.id]
            loser_node = self.id_position[loser.id]

            # Calculate edge of a node (end point of an arrow)
            lw_vector = loser_node.pos() - winner_node.pos()
            lw_vector_norm = self.calculateNorm(winner_node, loser_node)

            edge_point = (
                loser_node.pos() - lw_vector / lw_vector_norm * loser_node.RADIUS
            )

            # Connect nodes
            self.path.moveTo(winner_node.pos())
            self.path.lineTo(edge_point)

            edge = Edge(self.path, winner_node.pos(), edge_point)
            if weighted:
                edge.setWeight(weight)

            self.addItem(edge)

    def calculateCircle(self) -&gt; None:
        &#34;&#34;&#34;Calculer une cercle sur la bordure de laquelle les noeuds vont être placés.&#34;&#34;&#34;

        self.center = QPointF(self.view_size.width() / 2, self.view_size.height() / 2)
        # Radius = 70% of window size
        self.radius = min(self.center.x() * 0.7, self.center.y() * 0.7)
        # Angle between candidates in radians
        nb_candidates = len(self.election.candidates)
        self.angle = 0 if nb_candidates == 0 else 2 * pi / nb_candidates

    def calculateNorm(self, point1: QPointF, point2: QPointF) -&gt; float:
        &#34;&#34;&#34;Calculer la norme d&#39;un vecteur point1 -&gt; point2.

        Args:
            point1 (PySide6.QtCore.QPointF): point de départ d&#39;un vecteur.
            point2 (PySide6.QtCore.QPointF): point d&#39;arrivée d&#39;un vecteur.

        Returns:
            float: La norme d&#39;un vecteur.
        &#34;&#34;&#34;

        x1, y1 = point1.x(), point1.y()
        x2, y2 = point2.x(), point2.y()
        return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph"><code class="flex name class">
<span>class <span class="ident">DirectedGraph</span></span>
<span>(</span><span>view_size: PySide6.QtCore.QSize, voting_rule: str, parent: PySide6.QtWidgets.QWidget)</span>
</code></dt>
<dd>
<div class="desc"><p>Une scène sur laquelle un graphe orienté sera dessiné.</p>
<p>Initialiser une instance
d'une élection (pour le partage des données). Fixer la taille.
Définir le couleur de l'arrière plan. Initialiser un <code>PySide6.QtGui.QPainterPath</code> pour les arêtes. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>view_size</code></strong> :&ensp;<code>PySide6.QtCore.QSize</code></dt>
<dd>La taille d'un view associé.</dd>
<dt><strong><code>voting_rule</code></strong> :&ensp;<code>str</code></dt>
<dd>Une constante d'une règle du vote dont les résultats une scène dessinera.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>PySide6.QtWidgets.QWidget</code></dt>
<dd>Le parent d'une scène.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirectedGraph(QGraphicsScene):
    &#34;&#34;&#34;Une scène sur laquelle un graphe orienté sera dessiné.&#34;&#34;&#34;

    def __init__(self, view_size: QSize, voting_rule: str, parent: QWidget):
        &#34;&#34;&#34;Initialiser une instance  d&#39;une élection (pour le partage des données). Fixer la taille.
        Définir le couleur de l&#39;arrière plan. Initialiser un `PySide6.QtGui.QPainterPath` pour les arêtes. 

        Args:
            view_size (PySide6.QtCore.QSize): La taille d&#39;un view associé.
            voting_rule (str): Une constante d&#39;une règle du vote dont les résultats une scène dessinera.
            parent (PySide6.QtWidgets.QWidget): Le parent d&#39;une scène.
        &#34;&#34;&#34;

        super().__init__(parent)
        self.election = Election()

        # Un dict sera rempli dans initNodes
        self.id_position = dict()

        self.view_size = view_size
        self.voting_rule = voting_rule
        self.path = QPainterPath()

        # Couleur gris-claire
        self.setBackgroundBrush(QColor(238, 238, 238))
        self.calculateCircle()

    def drawGraphics(self, weighted: bool) -&gt; None:
        &#34;&#34;&#34;Initialiser et placer des noeuds et des arêtes d&#39;un graphe orienté.

        Args:
            weighted (bool): True s&#39;il faut représenter des poids. Sinon, False.
        &#34;&#34;&#34;

        self.initNodes()
        self.initEdges(weighted)

    def initNodes(self) -&gt; None:
        &#34;&#34;&#34;Initialiser et placer des noeuds. Remplir un dictionnaire `id_position` qui associe un ID d&#39;un candidat
        et noeud d&#39;un candidat.&#34;&#34;&#34;

        # Dict key : ID d&#39;un candidat, value : son noeud associé
        winner = self.election.choose_winner(self.voting_rule)

        for i in range(len(self.election.candidates)):
            x = self.center.x() + self.radius * cos(self.angle * i)
            y = self.center.y() + self.radius * sin(self.angle * i)

            candidate = self.election.candidates[i]
            node = Node(x, y, f&#34;{candidate.first_name} {candidate.last_name}&#34;)

            if candidate == winner:
                node.highlight()

            self.id_position[candidate.id] = node
            self.addItem(node)

    # draw edges between nodes
    def initEdges(self, weighted: bool) -&gt; None:
        &#34;&#34;&#34;Initialiser et placer des arêtes d&#39;un graphe.

        Args:
            weighted (bool): True s&#39;il faut représenter des poids. Sinon, False.
        &#34;&#34;&#34;

        # Les duels des candidats déjà remplis
        for (winner, loser), weight in self.election.duels_scores.items():

            winner_node = self.id_position[winner.id]
            loser_node = self.id_position[loser.id]

            # Calculate edge of a node (end point of an arrow)
            lw_vector = loser_node.pos() - winner_node.pos()
            lw_vector_norm = self.calculateNorm(winner_node, loser_node)

            edge_point = (
                loser_node.pos() - lw_vector / lw_vector_norm * loser_node.RADIUS
            )

            # Connect nodes
            self.path.moveTo(winner_node.pos())
            self.path.lineTo(edge_point)

            edge = Edge(self.path, winner_node.pos(), edge_point)
            if weighted:
                edge.setWeight(weight)

            self.addItem(edge)

    def calculateCircle(self) -&gt; None:
        &#34;&#34;&#34;Calculer une cercle sur la bordure de laquelle les noeuds vont être placés.&#34;&#34;&#34;

        self.center = QPointF(self.view_size.width() / 2, self.view_size.height() / 2)
        # Radius = 70% of window size
        self.radius = min(self.center.x() * 0.7, self.center.y() * 0.7)
        # Angle between candidates in radians
        nb_candidates = len(self.election.candidates)
        self.angle = 0 if nb_candidates == 0 else 2 * pi / nb_candidates

    def calculateNorm(self, point1: QPointF, point2: QPointF) -&gt; float:
        &#34;&#34;&#34;Calculer la norme d&#39;un vecteur point1 -&gt; point2.

        Args:
            point1 (PySide6.QtCore.QPointF): point de départ d&#39;un vecteur.
            point2 (PySide6.QtCore.QPointF): point d&#39;arrivée d&#39;un vecteur.

        Returns:
            float: La norme d&#39;un vecteur.
        &#34;&#34;&#34;

        x1, y1 = point1.x(), point1.y()
        x2, y2 = point2.x(), point2.y()
        return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PySide6.QtWidgets.QGraphicsScene</li>
<li>PySide6.QtCore.QObject</li>
<li>Shiboken.Object</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.staticMetaObject"><code class="name">var <span class="ident">staticMetaObject</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.calculateCircle"><code class="name flex">
<span>def <span class="ident">calculateCircle</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calculer une cercle sur la bordure de laquelle les noeuds vont être placés.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculateCircle(self) -&gt; None:
    &#34;&#34;&#34;Calculer une cercle sur la bordure de laquelle les noeuds vont être placés.&#34;&#34;&#34;

    self.center = QPointF(self.view_size.width() / 2, self.view_size.height() / 2)
    # Radius = 70% of window size
    self.radius = min(self.center.x() * 0.7, self.center.y() * 0.7)
    # Angle between candidates in radians
    nb_candidates = len(self.election.candidates)
    self.angle = 0 if nb_candidates == 0 else 2 * pi / nb_candidates</code></pre>
</details>
</dd>
<dt id="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.calculateNorm"><code class="name flex">
<span>def <span class="ident">calculateNorm</span></span>(<span>self, point1: PySide6.QtCore.QPointF, point2: PySide6.QtCore.QPointF) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculer la norme d'un vecteur point1 -&gt; point2.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point1</code></strong> :&ensp;<code>PySide6.QtCore.QPointF</code></dt>
<dd>point de départ d'un vecteur.</dd>
<dt><strong><code>point2</code></strong> :&ensp;<code>PySide6.QtCore.QPointF</code></dt>
<dd>point d'arrivée d'un vecteur.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>La norme d'un vecteur.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculateNorm(self, point1: QPointF, point2: QPointF) -&gt; float:
    &#34;&#34;&#34;Calculer la norme d&#39;un vecteur point1 -&gt; point2.

    Args:
        point1 (PySide6.QtCore.QPointF): point de départ d&#39;un vecteur.
        point2 (PySide6.QtCore.QPointF): point d&#39;arrivée d&#39;un vecteur.

    Returns:
        float: La norme d&#39;un vecteur.
    &#34;&#34;&#34;

    x1, y1 = point1.x(), point1.y()
    x2, y2 = point2.x(), point2.y()
    return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)</code></pre>
</details>
</dd>
<dt id="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.drawGraphics"><code class="name flex">
<span>def <span class="ident">drawGraphics</span></span>(<span>self, weighted: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialiser et placer des noeuds et des arêtes d'un graphe orienté.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>weighted</code></strong> :&ensp;<code>bool</code></dt>
<dd>True s'il faut représenter des poids. Sinon, False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawGraphics(self, weighted: bool) -&gt; None:
    &#34;&#34;&#34;Initialiser et placer des noeuds et des arêtes d&#39;un graphe orienté.

    Args:
        weighted (bool): True s&#39;il faut représenter des poids. Sinon, False.
    &#34;&#34;&#34;

    self.initNodes()
    self.initEdges(weighted)</code></pre>
</details>
</dd>
<dt id="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.initEdges"><code class="name flex">
<span>def <span class="ident">initEdges</span></span>(<span>self, weighted: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialiser et placer des arêtes d'un graphe.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>weighted</code></strong> :&ensp;<code>bool</code></dt>
<dd>True s'il faut représenter des poids. Sinon, False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initEdges(self, weighted: bool) -&gt; None:
    &#34;&#34;&#34;Initialiser et placer des arêtes d&#39;un graphe.

    Args:
        weighted (bool): True s&#39;il faut représenter des poids. Sinon, False.
    &#34;&#34;&#34;

    # Les duels des candidats déjà remplis
    for (winner, loser), weight in self.election.duels_scores.items():

        winner_node = self.id_position[winner.id]
        loser_node = self.id_position[loser.id]

        # Calculate edge of a node (end point of an arrow)
        lw_vector = loser_node.pos() - winner_node.pos()
        lw_vector_norm = self.calculateNorm(winner_node, loser_node)

        edge_point = (
            loser_node.pos() - lw_vector / lw_vector_norm * loser_node.RADIUS
        )

        # Connect nodes
        self.path.moveTo(winner_node.pos())
        self.path.lineTo(edge_point)

        edge = Edge(self.path, winner_node.pos(), edge_point)
        if weighted:
            edge.setWeight(weight)

        self.addItem(edge)</code></pre>
</details>
</dd>
<dt id="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.initNodes"><code class="name flex">
<span>def <span class="ident">initNodes</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialiser et placer des noeuds. Remplir un dictionnaire <code>id_position</code> qui associe un ID d'un candidat
et noeud d'un candidat.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initNodes(self) -&gt; None:
    &#34;&#34;&#34;Initialiser et placer des noeuds. Remplir un dictionnaire `id_position` qui associe un ID d&#39;un candidat
    et noeud d&#39;un candidat.&#34;&#34;&#34;

    # Dict key : ID d&#39;un candidat, value : son noeud associé
    winner = self.election.choose_winner(self.voting_rule)

    for i in range(len(self.election.candidates)):
        x = self.center.x() + self.radius * cos(self.angle * i)
        y = self.center.y() + self.radius * sin(self.angle * i)

        candidate = self.election.candidates[i]
        node = Node(x, y, f&#34;{candidate.first_name} {candidate.last_name}&#34;)

        if candidate == winner:
            node.highlight()

        self.id_position[candidate.id] = node
        self.addItem(node)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tzb.graphics.widget_results_utls.directed_graphs" href="index.html">tzb.graphics.widget_results_utls.directed_graphs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph" href="#tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph">DirectedGraph</a></code></h4>
<ul class="two-column">
<li><code><a title="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.calculateCircle" href="#tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.calculateCircle">calculateCircle</a></code></li>
<li><code><a title="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.calculateNorm" href="#tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.calculateNorm">calculateNorm</a></code></li>
<li><code><a title="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.drawGraphics" href="#tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.drawGraphics">drawGraphics</a></code></li>
<li><code><a title="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.initEdges" href="#tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.initEdges">initEdges</a></code></li>
<li><code><a title="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.initNodes" href="#tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.initNodes">initNodes</a></code></li>
<li><code><a title="tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.staticMetaObject" href="#tzb.graphics.widget_results_utls.directed_graphs.directed_graph.DirectedGraph.staticMetaObject">staticMetaObject</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>