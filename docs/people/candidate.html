<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>people.candidate API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>people.candidate</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from copy import deepcopy
from dataclasses import dataclass, field, InitVar
from typing import Dict, Union, List, Tuple, Optional

from numpy import clip
from .person import Person


@dataclass(kw_only=True, unsafe_hash=True, eq=True, order=True)
class Candidate(Person):
    &#34;&#34;&#34;Une classe permettant de représenter un candidat dans une élection.
    *Un couple (first_name, last_name) doit être unique*.
    Une comparaison des candidats est effectuée uniquement par leurs noms et prénoms.&#34;&#34;&#34;

    first_name: str = field(default=&#34;&#34;, hash=True, compare=True)
    &#34;&#34;&#34;Le prénom d&#39;un candidat.&#34;&#34;&#34;

    last_name: str = field(default=&#34;&#34;, hash=True, compare=True)
    &#34;&#34;&#34;Le nom d&#39;un candidat.&#34;&#34;&#34;

    dogmatism: float = field(default=-1.0, hash=True, compare=False)
    &#34;&#34;&#34;Sondages : Plus le taux de dogmatisme est élevé, plus le candidat est sûr de sa position politique
    et il est peu probable qu&#39;il décide de la changer, et inversement, moins le taux de dogmatisme est élevé,
    plus il est probable que le candidat décide de changer sa position politique
    ou d&#39;abandonner une élection et/ou former une alliance.  
    Si le taux de dogmatisme n&#39;est pas donné lors de l&#39;initialisation, il est généré selon la loi normale
    à l&#39;aide de `dogmatism_const`.
    &#34;&#34;&#34;

    opposition: float = field(default=-1.0, hash=True, compare=False)
    &#34;&#34;&#34;Sondages : Plus le taux d&#39;opposition est élevé, moins il est probable que le candidat décide
    de changer sa position politique en s&#39;approchant le gagnant d&#39;une élection, et inversement, 
    moins le taux d&#39;opposition est élevé, plus il est probable que le candidat décide de s&#39;approcher 
    du gagnant d&#39;une élection.  
    Si le taux d&#39;opposition n&#39;est pas donné lors de l&#39;initialisation, il est généré selon la loi normale
    à l&#39;aide de `opposition_const`.
    &#34;&#34;&#34;

    dogmatism_const: InitVar[Tuple[float, float]] = field(
        default=(0.5, 0.3), compare=False)
    &#34;&#34;&#34;Des paramètres (moyenne, écart-type) pour générer le taux de dogmatisme selon la loi normale.&#34;&#34;&#34;

    opposition_const: InitVar[Tuple[float, float]] = field(
        default=(0.5, 0.3), compare=False)
    &#34;&#34;&#34;Des paramètres (moyenne, écart-type) pour générer le taux d&#39; opposition selon la loi normale.&#34;&#34;&#34;

    # int -&gt; 1 round, float -&gt; Copeland, List -&gt; N rounds
    scores: Dict[str, Union[int, float, List[int]]] = field(
        default_factory=dict, hash=False, compare=False
    )
    &#34;&#34;&#34;Un dictionnaire des scores pour chaque règle de vote utilisée lors l&#39;élection.  
    Les types selon les règles de vote:  
        - int: des règles de vote à 1 tour  
        - float: une règle de vote *Copeland*  
        - List[int]: des règles de vote à plusieurs tours  
    &#34;&#34;&#34;

    def __post_init__(self, dogmatism_const, opposition_const):
        if self.dogmatism &lt; 0:
            mu, sigma = dogmatism_const
            self.dogmatism = Person.generate_parameter(
                mu=mu, sigma=sigma, lower_limit=0, upper_limit=1
            )
        if self.opposition:
            mu, sigma = opposition_const
            self.opposition = Person.generate_parameter(
                mu=mu, sigma=sigma, lower_limit=0, upper_limit=1
            )

    def __str__(self):
        x, y = self.position
        # return f&#34;Candidate({self.id}, ({x:.2f},{y:.2f}), {self.first_name}, {self.last_name}, {self.scores})&#34;
        # return f&#34;Candidate({self.id}, {self.first_name} {self.last_name}, domgat:{self.dogmatism:.2f}, oppos:{self.opposition:.2f})&#34;
        # return f&#34;Candidate({self.id}, {self.first_name} {self.last_name})&#34;
        return str(self.id)

    def __repr__(self):
        return self.__str__()
        
    def init_score(self, voting_rule: str, new_score: Union[int, float], list_type: Optional[bool] = False) -&gt; None:
        &#34;&#34;&#34;Initialise la case `scores[voting_rule]` avec `new_score`

        Args:
            voting_rule (str): La constante associée à une règle de vote.
            new_score (Union[int, float]): Le score avec lequel il faut initialiser la case.
            list_type (Optional[bool]): Doit être `True` si le type de `new_score` est `List` et il faut passer par `deepcopy`.
                Sinon, l&#39;initialisation est faite par une affectation simple. Default = `False`.
        &#34;&#34;&#34;

        if not list_type:
            self.scores[voting_rule] = new_score
        else:
            self.scores[voting_rule] = deepcopy(new_score)

    def add_score(self, voting_rule: str, score: Union[int, float]) -&gt; None:
        &#34;&#34;&#34;Ajoute le score `score` dans une case `scores[voting_rule]` vers le score déjà existant.
        Utiliser uniquement pour des règles de vote à un tour ou Condorcet-cohérentes.

        Args:
            voting_rule (str):  La constante associée à une règle de vote à un tour ou Condorcet-cohérente.
            score (Union[int, float]): Le score à ajouter.
        &#34;&#34;&#34;

        if voting_rule not in self.scores:
            self.init_score(voting_rule, 0)
        self.scores[voting_rule] += score

    # Round commence a partir de 0
    def add_score_round(self, voting_rule: str, score: Union[int, float], round: int) -&gt; None:
        &#34;&#34;&#34;Ajoute le score `score` dans une tour `round` dans une case `scores[voting_rule]`.
        Utiliser uniquement pour des règles de vote à plusieurs tours.

        Args:
            voting_rule (str):  La constante associée à une règle de vote à plusieurs tours.
            score (Union[int, float]): Le score à ajouter.
            round (int): Le tour de la règle de vote. Commence à partir de 0.

        Raises:
            IndexError: Si `round` est plus grand que le nombre des tours initialisé.
        &#34;&#34;&#34;

        if voting_rule not in self.scores:
            self.init_score(voting_rule, [0] * round, True)
        if round &gt;= len(self.scores[voting_rule]):
            raise IndexError
        self.scores[voting_rule][round] += score

    def move_to_avg(self, positions: List[tuple[float, float]], travel_dist: float) -&gt; None:
        &#34;&#34;&#34;Change la position d&#39;un candidat en s&#39;approchant de la position moyenne des positions données.
        Le taux de changement de la position est déterminé par `travel_dist`.

        Args:
            positions (List[tuple[float, float]]): Une liste des positions à partir de laquelle une position moyenne sera calculée.
            travel_dist (float): La distance à laquelle un candidat va bouger. Doit être bornée entre 0 et 1.
        &#34;&#34;&#34;

        sum_x, sum_y = 0, 0
        for x, y in positions:
            sum_x, sum_y = sum_x + x, sum_y + y
        x_goal, y_goal = sum_x / len(positions), sum_y / len(positions)

        self.move_to_point((x_goal, y_goal), travel_dist)

    def move_to_point(self, position_goal, travel_dist) -&gt; None:
        &#34;&#34;&#34;Change la position d&#39;un candidat en s&#39;approchant de la position `position_goal`.
        Le taux de changement de la position est déterminé par `travel_dist`.
        Si les coordonnées de la nouvelle position sont hors bornes, alors elles sont coupées de -1 à 1.

        Args:
            position_goal (tuple[float, float]): La position vers laquelle il faut s&#39;approcher. Chaque coordonnée doit être borné
                entre -1 et 1.
            travel_dist: La distance à laquelle un candidat va bouger. Doit être bornée entre 0 et 1.
        &#34;&#34;&#34;

        x_curr, y_curr = self.position
        x_goal, y_goal = position_goal

        # Move towards x_goal, y_goal
        x_curr += (x_goal - x_curr) * travel_dist
        y_curr += (y_goal - y_curr) * travel_dist
        x_curr = clip(x_curr, -1, 1)
        y_curr = clip(y_curr, -1, 1)
        self.position = (x_curr, y_curr)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="people.candidate.Candidate"><code class="flex name class">
<span>class <span class="ident">Candidate</span></span>
<span>(</span><span>*, id: int, position: tuple[float, float], first_name: str = '', last_name: str = '', dogmatism: float = -1.0, opposition: float = -1.0, dogmatism_const: dataclasses.InitVar[typing.Tuple[float, float]] = (0.5, 0.3), opposition_const: dataclasses.InitVar[typing.Tuple[float, float]] = (0.5, 0.3), scores: Dict[str, Union[int, float, List[int]]] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Une classe permettant de représenter un candidat dans une élection.
<em>Un couple (first_name, last_name) doit être unique</em>.
Une comparaison des candidats est effectuée uniquement par leurs noms et prénoms.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(kw_only=True, unsafe_hash=True, eq=True, order=True)
class Candidate(Person):
    &#34;&#34;&#34;Une classe permettant de représenter un candidat dans une élection.
    *Un couple (first_name, last_name) doit être unique*.
    Une comparaison des candidats est effectuée uniquement par leurs noms et prénoms.&#34;&#34;&#34;

    first_name: str = field(default=&#34;&#34;, hash=True, compare=True)
    &#34;&#34;&#34;Le prénom d&#39;un candidat.&#34;&#34;&#34;

    last_name: str = field(default=&#34;&#34;, hash=True, compare=True)
    &#34;&#34;&#34;Le nom d&#39;un candidat.&#34;&#34;&#34;

    dogmatism: float = field(default=-1.0, hash=True, compare=False)
    &#34;&#34;&#34;Sondages : Plus le taux de dogmatisme est élevé, plus le candidat est sûr de sa position politique
    et il est peu probable qu&#39;il décide de la changer, et inversement, moins le taux de dogmatisme est élevé,
    plus il est probable que le candidat décide de changer sa position politique
    ou d&#39;abandonner une élection et/ou former une alliance.  
    Si le taux de dogmatisme n&#39;est pas donné lors de l&#39;initialisation, il est généré selon la loi normale
    à l&#39;aide de `dogmatism_const`.
    &#34;&#34;&#34;

    opposition: float = field(default=-1.0, hash=True, compare=False)
    &#34;&#34;&#34;Sondages : Plus le taux d&#39;opposition est élevé, moins il est probable que le candidat décide
    de changer sa position politique en s&#39;approchant le gagnant d&#39;une élection, et inversement, 
    moins le taux d&#39;opposition est élevé, plus il est probable que le candidat décide de s&#39;approcher 
    du gagnant d&#39;une élection.  
    Si le taux d&#39;opposition n&#39;est pas donné lors de l&#39;initialisation, il est généré selon la loi normale
    à l&#39;aide de `opposition_const`.
    &#34;&#34;&#34;

    dogmatism_const: InitVar[Tuple[float, float]] = field(
        default=(0.5, 0.3), compare=False)
    &#34;&#34;&#34;Des paramètres (moyenne, écart-type) pour générer le taux de dogmatisme selon la loi normale.&#34;&#34;&#34;

    opposition_const: InitVar[Tuple[float, float]] = field(
        default=(0.5, 0.3), compare=False)
    &#34;&#34;&#34;Des paramètres (moyenne, écart-type) pour générer le taux d&#39; opposition selon la loi normale.&#34;&#34;&#34;

    # int -&gt; 1 round, float -&gt; Copeland, List -&gt; N rounds
    scores: Dict[str, Union[int, float, List[int]]] = field(
        default_factory=dict, hash=False, compare=False
    )
    &#34;&#34;&#34;Un dictionnaire des scores pour chaque règle de vote utilisée lors l&#39;élection.  
    Les types selon les règles de vote:  
        - int: des règles de vote à 1 tour  
        - float: une règle de vote *Copeland*  
        - List[int]: des règles de vote à plusieurs tours  
    &#34;&#34;&#34;

    def __post_init__(self, dogmatism_const, opposition_const):
        if self.dogmatism &lt; 0:
            mu, sigma = dogmatism_const
            self.dogmatism = Person.generate_parameter(
                mu=mu, sigma=sigma, lower_limit=0, upper_limit=1
            )
        if self.opposition:
            mu, sigma = opposition_const
            self.opposition = Person.generate_parameter(
                mu=mu, sigma=sigma, lower_limit=0, upper_limit=1
            )

    def __str__(self):
        x, y = self.position
        # return f&#34;Candidate({self.id}, ({x:.2f},{y:.2f}), {self.first_name}, {self.last_name}, {self.scores})&#34;
        # return f&#34;Candidate({self.id}, {self.first_name} {self.last_name}, domgat:{self.dogmatism:.2f}, oppos:{self.opposition:.2f})&#34;
        # return f&#34;Candidate({self.id}, {self.first_name} {self.last_name})&#34;
        return str(self.id)

    def __repr__(self):
        return self.__str__()
        
    def init_score(self, voting_rule: str, new_score: Union[int, float], list_type: Optional[bool] = False) -&gt; None:
        &#34;&#34;&#34;Initialise la case `scores[voting_rule]` avec `new_score`

        Args:
            voting_rule (str): La constante associée à une règle de vote.
            new_score (Union[int, float]): Le score avec lequel il faut initialiser la case.
            list_type (Optional[bool]): Doit être `True` si le type de `new_score` est `List` et il faut passer par `deepcopy`.
                Sinon, l&#39;initialisation est faite par une affectation simple. Default = `False`.
        &#34;&#34;&#34;

        if not list_type:
            self.scores[voting_rule] = new_score
        else:
            self.scores[voting_rule] = deepcopy(new_score)

    def add_score(self, voting_rule: str, score: Union[int, float]) -&gt; None:
        &#34;&#34;&#34;Ajoute le score `score` dans une case `scores[voting_rule]` vers le score déjà existant.
        Utiliser uniquement pour des règles de vote à un tour ou Condorcet-cohérentes.

        Args:
            voting_rule (str):  La constante associée à une règle de vote à un tour ou Condorcet-cohérente.
            score (Union[int, float]): Le score à ajouter.
        &#34;&#34;&#34;

        if voting_rule not in self.scores:
            self.init_score(voting_rule, 0)
        self.scores[voting_rule] += score

    # Round commence a partir de 0
    def add_score_round(self, voting_rule: str, score: Union[int, float], round: int) -&gt; None:
        &#34;&#34;&#34;Ajoute le score `score` dans une tour `round` dans une case `scores[voting_rule]`.
        Utiliser uniquement pour des règles de vote à plusieurs tours.

        Args:
            voting_rule (str):  La constante associée à une règle de vote à plusieurs tours.
            score (Union[int, float]): Le score à ajouter.
            round (int): Le tour de la règle de vote. Commence à partir de 0.

        Raises:
            IndexError: Si `round` est plus grand que le nombre des tours initialisé.
        &#34;&#34;&#34;

        if voting_rule not in self.scores:
            self.init_score(voting_rule, [0] * round, True)
        if round &gt;= len(self.scores[voting_rule]):
            raise IndexError
        self.scores[voting_rule][round] += score

    def move_to_avg(self, positions: List[tuple[float, float]], travel_dist: float) -&gt; None:
        &#34;&#34;&#34;Change la position d&#39;un candidat en s&#39;approchant de la position moyenne des positions données.
        Le taux de changement de la position est déterminé par `travel_dist`.

        Args:
            positions (List[tuple[float, float]]): Une liste des positions à partir de laquelle une position moyenne sera calculée.
            travel_dist (float): La distance à laquelle un candidat va bouger. Doit être bornée entre 0 et 1.
        &#34;&#34;&#34;

        sum_x, sum_y = 0, 0
        for x, y in positions:
            sum_x, sum_y = sum_x + x, sum_y + y
        x_goal, y_goal = sum_x / len(positions), sum_y / len(positions)

        self.move_to_point((x_goal, y_goal), travel_dist)

    def move_to_point(self, position_goal, travel_dist) -&gt; None:
        &#34;&#34;&#34;Change la position d&#39;un candidat en s&#39;approchant de la position `position_goal`.
        Le taux de changement de la position est déterminé par `travel_dist`.
        Si les coordonnées de la nouvelle position sont hors bornes, alors elles sont coupées de -1 à 1.

        Args:
            position_goal (tuple[float, float]): La position vers laquelle il faut s&#39;approcher. Chaque coordonnée doit être borné
                entre -1 et 1.
            travel_dist: La distance à laquelle un candidat va bouger. Doit être bornée entre 0 et 1.
        &#34;&#34;&#34;

        x_curr, y_curr = self.position
        x_goal, y_goal = position_goal

        # Move towards x_goal, y_goal
        x_curr += (x_goal - x_curr) * travel_dist
        y_curr += (y_goal - y_curr) * travel_dist
        x_curr = clip(x_curr, -1, 1)
        y_curr = clip(y_curr, -1, 1)
        self.position = (x_curr, y_curr)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="people.person.Person" href="person.html#people.person.Person">Person</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="people.candidate.Candidate.dogmatism"><code class="name">var <span class="ident">dogmatism</span> : float</code></dt>
<dd>
<div class="desc"><p>Sondages : Plus le taux de dogmatisme est élevé, plus le candidat est sûr de sa position politique
et il est peu probable qu'il décide de la changer, et inversement, moins le taux de dogmatisme est élevé,
plus il est probable que le candidat décide de changer sa position politique
ou d'abandonner une élection et/ou former une alliance.<br>
Si le taux de dogmatisme n'est pas donné lors de l'initialisation, il est généré selon la loi normale
à l'aide de <code>dogmatism_const</code>.</p></div>
</dd>
<dt id="people.candidate.Candidate.dogmatism_const"><code class="name">var <span class="ident">dogmatism_const</span> : dataclasses.InitVar[typing.Tuple[float, float]]</code></dt>
<dd>
<div class="desc"><p>Des paramètres (moyenne, écart-type) pour générer le taux de dogmatisme selon la loi normale.</p></div>
</dd>
<dt id="people.candidate.Candidate.first_name"><code class="name">var <span class="ident">first_name</span> : str</code></dt>
<dd>
<div class="desc"><p>Le prénom d'un candidat.</p></div>
</dd>
<dt id="people.candidate.Candidate.last_name"><code class="name">var <span class="ident">last_name</span> : str</code></dt>
<dd>
<div class="desc"><p>Le nom d'un candidat.</p></div>
</dd>
<dt id="people.candidate.Candidate.opposition"><code class="name">var <span class="ident">opposition</span> : float</code></dt>
<dd>
<div class="desc"><p>Sondages : Plus le taux d'opposition est élevé, moins il est probable que le candidat décide
de changer sa position politique en s'approchant le gagnant d'une élection, et inversement,
moins le taux d'opposition est élevé, plus il est probable que le candidat décide de s'approcher
du gagnant d'une élection.<br>
Si le taux d'opposition n'est pas donné lors de l'initialisation, il est généré selon la loi normale
à l'aide de <code>opposition_const</code>.</p></div>
</dd>
<dt id="people.candidate.Candidate.opposition_const"><code class="name">var <span class="ident">opposition_const</span> : dataclasses.InitVar[typing.Tuple[float, float]]</code></dt>
<dd>
<div class="desc"><p>Des paramètres (moyenne, écart-type) pour générer le taux d' opposition selon la loi normale.</p></div>
</dd>
<dt id="people.candidate.Candidate.scores"><code class="name">var <span class="ident">scores</span> : Dict[str, Union[int, float, List[int]]]</code></dt>
<dd>
<div class="desc"><p>Un dictionnaire des scores pour chaque règle de vote utilisée lors l'élection.<br>
Les types selon les règles de vote:<br>
- int: des règles de vote à 1 tour<br>
- float: une règle de vote <em>Copeland</em><br>
- List[int]: des règles de vote à plusieurs tours</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="people.candidate.Candidate.add_score"><code class="name flex">
<span>def <span class="ident">add_score</span></span>(<span>self, voting_rule: str, score: Union[int, float]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Ajoute le score <code>score</code> dans une case <code>scores[voting_rule]</code> vers le score déjà existant.
Utiliser uniquement pour des règles de vote à un tour ou Condorcet-cohérentes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voting_rule</code></strong> :&ensp;<code>str</code></dt>
<dd>La constante associée à une règle de vote à un tour ou Condorcet-cohérente.</dd>
<dt><strong><code>score</code></strong> :&ensp;<code>Union[int, float]</code></dt>
<dd>Le score à ajouter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_score(self, voting_rule: str, score: Union[int, float]) -&gt; None:
    &#34;&#34;&#34;Ajoute le score `score` dans une case `scores[voting_rule]` vers le score déjà existant.
    Utiliser uniquement pour des règles de vote à un tour ou Condorcet-cohérentes.

    Args:
        voting_rule (str):  La constante associée à une règle de vote à un tour ou Condorcet-cohérente.
        score (Union[int, float]): Le score à ajouter.
    &#34;&#34;&#34;

    if voting_rule not in self.scores:
        self.init_score(voting_rule, 0)
    self.scores[voting_rule] += score</code></pre>
</details>
</dd>
<dt id="people.candidate.Candidate.add_score_round"><code class="name flex">
<span>def <span class="ident">add_score_round</span></span>(<span>self, voting_rule: str, score: Union[int, float], round: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Ajoute le score <code>score</code> dans une tour <code>round</code> dans une case <code>scores[voting_rule]</code>.
Utiliser uniquement pour des règles de vote à plusieurs tours.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voting_rule</code></strong> :&ensp;<code>str</code></dt>
<dd>La constante associée à une règle de vote à plusieurs tours.</dd>
<dt><strong><code>score</code></strong> :&ensp;<code>Union[int, float]</code></dt>
<dd>Le score à ajouter.</dd>
<dt><strong><code>round</code></strong> :&ensp;<code>int</code></dt>
<dd>Le tour de la règle de vote. Commence à partir de 0.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>IndexError</code></dt>
<dd>Si <code>round</code> est plus grand que le nombre des tours initialisé.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_score_round(self, voting_rule: str, score: Union[int, float], round: int) -&gt; None:
    &#34;&#34;&#34;Ajoute le score `score` dans une tour `round` dans une case `scores[voting_rule]`.
    Utiliser uniquement pour des règles de vote à plusieurs tours.

    Args:
        voting_rule (str):  La constante associée à une règle de vote à plusieurs tours.
        score (Union[int, float]): Le score à ajouter.
        round (int): Le tour de la règle de vote. Commence à partir de 0.

    Raises:
        IndexError: Si `round` est plus grand que le nombre des tours initialisé.
    &#34;&#34;&#34;

    if voting_rule not in self.scores:
        self.init_score(voting_rule, [0] * round, True)
    if round &gt;= len(self.scores[voting_rule]):
        raise IndexError
    self.scores[voting_rule][round] += score</code></pre>
</details>
</dd>
<dt id="people.candidate.Candidate.init_score"><code class="name flex">
<span>def <span class="ident">init_score</span></span>(<span>self, voting_rule: str, new_score: Union[int, float], list_type: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialise la case <code>scores[voting_rule]</code> avec <code>new_score</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voting_rule</code></strong> :&ensp;<code>str</code></dt>
<dd>La constante associée à une règle de vote.</dd>
<dt><strong><code>new_score</code></strong> :&ensp;<code>Union[int, float]</code></dt>
<dd>Le score avec lequel il faut initialiser la case.</dd>
<dt><strong><code>list_type</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Doit être <code>True</code> si le type de <code>new_score</code> est <code>List</code> et il faut passer par <code>deepcopy</code>.
Sinon, l'initialisation est faite par une affectation simple. Default = <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_score(self, voting_rule: str, new_score: Union[int, float], list_type: Optional[bool] = False) -&gt; None:
    &#34;&#34;&#34;Initialise la case `scores[voting_rule]` avec `new_score`

    Args:
        voting_rule (str): La constante associée à une règle de vote.
        new_score (Union[int, float]): Le score avec lequel il faut initialiser la case.
        list_type (Optional[bool]): Doit être `True` si le type de `new_score` est `List` et il faut passer par `deepcopy`.
            Sinon, l&#39;initialisation est faite par une affectation simple. Default = `False`.
    &#34;&#34;&#34;

    if not list_type:
        self.scores[voting_rule] = new_score
    else:
        self.scores[voting_rule] = deepcopy(new_score)</code></pre>
</details>
</dd>
<dt id="people.candidate.Candidate.move_to_avg"><code class="name flex">
<span>def <span class="ident">move_to_avg</span></span>(<span>self, positions: List[tuple[float, float]], travel_dist: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Change la position d'un candidat en s'approchant de la position moyenne des positions données.
Le taux de changement de la position est déterminé par <code>travel_dist</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>List[tuple[float, float]]</code></dt>
<dd>Une liste des positions à partir de laquelle une position moyenne sera calculée.</dd>
<dt><strong><code>travel_dist</code></strong> :&ensp;<code>float</code></dt>
<dd>La distance à laquelle un candidat va bouger. Doit être bornée entre 0 et 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_to_avg(self, positions: List[tuple[float, float]], travel_dist: float) -&gt; None:
    &#34;&#34;&#34;Change la position d&#39;un candidat en s&#39;approchant de la position moyenne des positions données.
    Le taux de changement de la position est déterminé par `travel_dist`.

    Args:
        positions (List[tuple[float, float]]): Une liste des positions à partir de laquelle une position moyenne sera calculée.
        travel_dist (float): La distance à laquelle un candidat va bouger. Doit être bornée entre 0 et 1.
    &#34;&#34;&#34;

    sum_x, sum_y = 0, 0
    for x, y in positions:
        sum_x, sum_y = sum_x + x, sum_y + y
    x_goal, y_goal = sum_x / len(positions), sum_y / len(positions)

    self.move_to_point((x_goal, y_goal), travel_dist)</code></pre>
</details>
</dd>
<dt id="people.candidate.Candidate.move_to_point"><code class="name flex">
<span>def <span class="ident">move_to_point</span></span>(<span>self, position_goal, travel_dist) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Change la position d'un candidat en s'approchant de la position <code>position_goal</code>.
Le taux de changement de la position est déterminé par <code>travel_dist</code>.
Si les coordonnées de la nouvelle position sont hors bornes, alors elles sont coupées de -1 à 1.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position_goal</code></strong> :&ensp;<code>tuple[float, float]</code></dt>
<dd>La position vers laquelle il faut s'approcher. Chaque coordonnée doit être borné
entre -1 et 1.</dd>
<dt><strong><code>travel_dist</code></strong></dt>
<dd>La distance à laquelle un candidat va bouger. Doit être bornée entre 0 et 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_to_point(self, position_goal, travel_dist) -&gt; None:
    &#34;&#34;&#34;Change la position d&#39;un candidat en s&#39;approchant de la position `position_goal`.
    Le taux de changement de la position est déterminé par `travel_dist`.
    Si les coordonnées de la nouvelle position sont hors bornes, alors elles sont coupées de -1 à 1.

    Args:
        position_goal (tuple[float, float]): La position vers laquelle il faut s&#39;approcher. Chaque coordonnée doit être borné
            entre -1 et 1.
        travel_dist: La distance à laquelle un candidat va bouger. Doit être bornée entre 0 et 1.
    &#34;&#34;&#34;

    x_curr, y_curr = self.position
    x_goal, y_goal = position_goal

    # Move towards x_goal, y_goal
    x_curr += (x_goal - x_curr) * travel_dist
    y_curr += (y_goal - y_curr) * travel_dist
    x_curr = clip(x_curr, -1, 1)
    y_curr = clip(y_curr, -1, 1)
    self.position = (x_curr, y_curr)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="people.person.Person" href="person.html#people.person.Person">Person</a></b></code>:
<ul class="hlist">
<li><code><a title="people.person.Person.generate_parameter" href="person.html#people.person.Person.generate_parameter">generate_parameter</a></code></li>
<li><code><a title="people.person.Person.id" href="person.html#people.person.Person.id">id</a></code></li>
<li><code><a title="people.person.Person.position" href="person.html#people.person.Person.position">position</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="people" href="index.html">people</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="people.candidate.Candidate" href="#people.candidate.Candidate">Candidate</a></code></h4>
<ul class="two-column">
<li><code><a title="people.candidate.Candidate.add_score" href="#people.candidate.Candidate.add_score">add_score</a></code></li>
<li><code><a title="people.candidate.Candidate.add_score_round" href="#people.candidate.Candidate.add_score_round">add_score_round</a></code></li>
<li><code><a title="people.candidate.Candidate.dogmatism" href="#people.candidate.Candidate.dogmatism">dogmatism</a></code></li>
<li><code><a title="people.candidate.Candidate.dogmatism_const" href="#people.candidate.Candidate.dogmatism_const">dogmatism_const</a></code></li>
<li><code><a title="people.candidate.Candidate.first_name" href="#people.candidate.Candidate.first_name">first_name</a></code></li>
<li><code><a title="people.candidate.Candidate.init_score" href="#people.candidate.Candidate.init_score">init_score</a></code></li>
<li><code><a title="people.candidate.Candidate.last_name" href="#people.candidate.Candidate.last_name">last_name</a></code></li>
<li><code><a title="people.candidate.Candidate.move_to_avg" href="#people.candidate.Candidate.move_to_avg">move_to_avg</a></code></li>
<li><code><a title="people.candidate.Candidate.move_to_point" href="#people.candidate.Candidate.move_to_point">move_to_point</a></code></li>
<li><code><a title="people.candidate.Candidate.opposition" href="#people.candidate.Candidate.opposition">opposition</a></code></li>
<li><code><a title="people.candidate.Candidate.opposition_const" href="#people.candidate.Candidate.opposition_const">opposition_const</a></code></li>
<li><code><a title="people.candidate.Candidate.scores" href="#people.candidate.Candidate.scores">scores</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>