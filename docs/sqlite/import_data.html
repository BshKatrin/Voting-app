<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sqlite.import_data API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sqlite.import_data</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from sqlite3 import Connection
from typing import Set, Dict

from electoral_systems import Election, VotingRulesConstants
from people import Candidate, Elector

# For docs generation only
__pdoc__ = {
    &#39;ImportData._check_tables&#39;: True,
    &#39;ImportData._get_existing_tables&#39;: True,
    &#39;ImportData._check_columns&#39;: True,
    &#39;ImportData._check_columns_people&#39;: True,
    &#39;ImportData._import_results&#39;: True,
    &#39;ImportData._import_one_round&#39;: True,
    &#39;ImportData._import_multi_round&#39;: True,
    &#39;ImportData._import_condorcet&#39;: True,
    &#39;ImportData._import_config&#39;: True,
}


class ImportData:
    &#34;&#34;&#34;A class which provides functionnality for data import. SQLite3 is used.&#34;&#34;&#34;

    election: Election = Election()
    IMPORT: str = &#34;I&#34;

    @classmethod
    def _check_tables(cls, tables_to_check: Set[str], existing_tables: Set[str]) -&gt; tuple[bool, Set[str]]:
        &#34;&#34;&#34;Verify if tables in `tables_to_check` exist in database. Tables in database are listed in `existing_tables`.

        Args:
            tables_to_check (Set[str]): Table names whose existence should be verified.
            existing_tables (Set[str]): Table names that exist in database.

        Returns:
            tuple[bool, Set[str]]: A bool `True` if at least one table is missing in database and a set of missing table names.
                Otherwise, a bool `False` if all tables exist in DB, a set is empty in that case.
        &#34;&#34;&#34;

        missing_tables = tables_to_check - (tables_to_check &amp; existing_tables)
        return (bool(missing_tables), missing_tables)

    @classmethod
    def _get_existing_tables(cls, connection: Connection) -&gt; Set[str]:
        &#34;&#34;&#34;Get names of all existing tables in database. 

        Args:
            connection (sqlite3.Connection): SQLite connection.

        Returns:
            Set[str]: A set of table names.
        &#34;&#34;&#34;

        cursor = connection.cursor()
        cursor.execute(&#34;SELECT name FROM sqlite_master WHERE type = &#39;table&#39;&#34;)
        return {row[0] for row in cursor.fetchall()}

    @classmethod
    def _check_columns(cls, connection: Connection, tables_cols: Dict[str, tuple[str, str]]) -&gt; bool:
        &#34;&#34;&#34;Verify column names and their type affinity.

        Args:
            connection (sqlite3.Connection): SQLite connection.
            tables_cols (Dict[str, tuple[str, str]]): A dictionary whose keys are table names (existing in database),
                and values are column names ant type affinity which should be verified.

        Returns:
            bool: `True` if every table all specified columns with the correct type affinity. `False` otherwise.
        &#34;&#34;&#34;

        cursor = connection.cursor()
        for table, columns in tables_cols.items():
            cursor.execute(
                f&#34;SELECT name, type FROM pragma_table_info(&#39;{table}&#39;)&#34;)
            existing_columns = {(row[0], row[1]) for row in cursor.fetchall()}
            missing_columns = columns - (columns &amp; existing_columns)
            if missing_columns:
                return True
        return False

    @classmethod
    def _check_columns_people(cls, connection: Connection) -&gt; bool:
        &#34;&#34;&#34;Verify column names and their type affinity in tables for electors and candidates.

        Args:
            connection (sqlite3.Connection): SQLite connection.

        Returns:
            bool: `True` if every table has all necessary columns with the correct type affinity. 
        &#34;&#34;&#34;

        return cls._check_columns(
            connection,
            {
                &#34;candidates&#34;: {
                    (&#34;id&#34;, &#34;INTEGER&#34;),
                    (&#34;x&#34;, &#34;REAL&#34;),
                    (&#34;y&#34;, &#34;REAL&#34;),
                    (&#34;first_name&#34;, &#34;TEXT&#34;),
                    (&#34;last_name&#34;, &#34;TEXT&#34;),
                    (&#34;dogmatism&#34;, &#34;REAL&#34;),
                    (&#34;opposition&#34;, &#34;REAL&#34;),
                },
                &#34;electors&#34;: {
                    (&#34;id&#34;, &#34;INTEGER&#34;),
                    (&#34;x&#34;, &#34;REAL&#34;),
                    (&#34;y&#34;, &#34;REAL&#34;),
                    (&#34;weight&#34;, &#34;INTEGER&#34;),
                    (&#34;knowledge&#34;, &#34;REAL&#34;),
                },
            },
        )

    @classmethod
    def import_people(cls, connection: Connection, with_results: bool) -&gt; tuple[bool, str]:
        &#34;&#34;&#34;Import data to the election from the database. Electors and candidates data are imported in any case. 
        Results data are imported only if necessary. Make all necessary verification on tables and its columns.

        Args:
            connection (sqlite3.Connection): SQLite connection.
            with_results (bool): `True` is results should be imported. `False`, otherwise.

        Returns:
            tuple[bool, str]: Un booléen `True` si les données ont été importées avec succès, `False` si l&#39;erreur est survenue.
                Une chaîne de caractères avec le message.
        &#34;&#34;&#34;

        if with_results:
            return cls.import_people_with_results(connection)
        return cls.import_people_no_results(connection)

    @classmethod
    def import_people_no_results(cls, connection: Connection) -&gt; tuple[bool, str]:
        &#34;&#34;&#34;Import data (candidates, electors only) in the election from the database.
        Make necessary verifications on tables and columns.

        Args:
            connection (sqlite3.Connection): SQLite connection.

        Returns:
            tuple[bool, str]: A bool `True` if data was imported succesfully, `False` if an error occurred.
                A string with message.
        &#34;&#34;&#34;

        existing_tables = cls._get_existing_tables(connection)
        # Check tables
        missing, missing_tables = cls._check_tables(
            {&#34;candidates&#34;, &#34;electors&#34;}, existing_tables
        )
        if missing:
            return False, f&#34;Tables {missing_tables} are not found&#34;

        # Check columns
        missing = cls._check_columns_people(connection)

        if missing:
            return False, f&#34;Database does not correspond&#34;

        cursor = connection.cursor()

        cursor.execute(&#34;SELECT x, y, first_name, last_name FROM candidates&#34;)
        candidates_data = cursor.fetchall()
       
        for x, y, first_name, last_name in candidates_data:
            id = next(cls.election.id_iter)
            cls.election.add_candidate_import(
                Candidate(
                    id=id, position=(
                        x, y), first_name=first_name, last_name=last_name
                )
            )

        cursor.execute(&#34;SELECT x, y, weight, knowledge FROM electors&#34;)
        electors_data = cursor.fetchall()

        for x, y, weight, knowledge in electors_data:
            id = next(cls.election.id_iter)
            cls.election.add_elector_import(
                Elector(id=id, position=(x, y),
                        weight=weight, knowledge=knowledge)
            )
        return True, &#34;Data imported&#34;

    @classmethod
    def import_people_with_results(cls, connection: Connection) -&gt; tuple[bool, str]:
        &#34;&#34;&#34;Import data (candidates, electors, results) to the election from the database. Make necessary verification on 
        tables and its columns. Import election settings if such table exists. Delete all existing data in the election.

        Args:
            connection (sqlite3.Connection): SQLite connection.

        Returns:
            tuple[bool, str]: A bool `True` if data was imported succesfully, `False` if an error occurred.
                A string with message.
        &#34;&#34;&#34;

        cls.election.delete_all_data()
        cls.election.nb_polls = 0
        # Check tables
        existing_tables = cls._get_existing_tables(connection)
        missing, missing_tables = cls._check_tables(
            {&#34;candidates&#34;, &#34;electors&#34;}, existing_tables
        )
        if missing:
            return False, f&#34;Tables {missing_tables} are not found&#34;

        # Check columns
        missing = cls._check_columns_people(connection)
        if missing:
            return False, f&#34;Database does not correspond&#34;

        cursor = connection.cursor()

        cursor.execute(&#34;SELECT * FROM candidates&#34;)
        candidates_data = cursor.fetchall()

        # id : candidate
        candidates_id_assoc = dict()

        for id, x, y, first_name, last_name, dogm, oppos in candidates_data:
            new_candidate = Candidate(
                id=next(cls.election.id_iter),
                position=(x, y),
                first_name=first_name,
                last_name=last_name,
                dogmatism=dogm,
                opposition=oppos,
            )
            cls.election.add_candidate_import(new_candidate)
            candidates_id_assoc[id] = new_candidate

        cursor.execute(&#34;SELECT * FROM electors&#34;)
        electors_data = cursor.fetchall()

        for id, x, y, weight, knowledge in electors_data:
            new_elector = Elector(
                id=id,
                position=(x, y),
                weight=weight,
                knowledge=knowledge,
            )
            cls.election.add_elector_import(new_elector)

        table_missing, _ = cls._check_tables({&#34;settings&#34;}, existing_tables)
        cls._import_config(connection, table_missing)
        return cls._import_results(connection, existing_tables, candidates_id_assoc)

    @classmethod
    def _import_results(cls, connection: Connection, existing_tables: Set[str], assoc: Dict[int, Candidate]) -&gt; tuple[bool, str]:
        &#34;&#34;&#34;Import results of each voting rule existing in the database to the election. 
        Make necessary verifications on tables and its columns. 

        Args:
            connection (sqlite3.Connection): SQLite connection.
            existing_tables (Set[str]): A set of names of tables existing in database.
            assoc (Dict[int, people.candidate.Candidate]): A dictionary associating each candidate ID
                (ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.

        Returns:
            tuple[bool, str]: A bool `True` if data was imported succesfully, `False` if an error occurred.
                A string with message.
        &#34;&#34;&#34;

        _, missing_tables = cls._check_tables(
            {&#34;results_one_round&#34;, &#34;results_multi_round&#34;, &#34;results_condorcet&#34;},
            existing_tables,
        )

        if len(missing_tables) == 3:
            return False, &#34;No tables related to scores found&#34;

        if &#34;results_one_round&#34; in existing_tables:
            # Check columns
            missing = cls._check_columns(
                connection,
                {
                    &#34;results_one_round&#34;: {
                        (&#34;candidate_id&#34;, &#34;INTEGER&#34;),
                        (&#34;voting_rule&#34;, &#34;TEXT&#34;),
                        (&#34;score&#34;, &#34;REAL&#34;),
                    },
                },
            )
            if missing:
                return False, f&#34;Database does not correspond&#34;

            cls._import_one_round(connection, assoc)

        if &#34;results_multi_round&#34; in existing_tables:
            missing = cls._check_columns(
                connection,
                {
                    &#34;results_multi_round&#34;: {
                        (&#34;candidate_id&#34;, &#34;INTEGER&#34;),
                        (&#34;voting_rule&#34;, &#34;TEXT&#34;),
                        (&#34;round&#34;, &#34;INTEGER&#34;),
                        (&#34;score&#34;, &#34;REAL&#34;),
                    },
                },
            )
            if missing:
                return False, f&#34;Database does not correspond&#34;
            cls._import_multi_round(connection, assoc)

        if (&#34;results_condorcet&#34; in existing_tables and &#34;condorcet_duels&#34; in existing_tables):
            missing = cls._check_columns(
                connection,
                {
                    &#34;results_condorcet&#34;: {
                        (&#34;candidate_id&#34;, &#34;INTEGER&#34;),
                        (&#34;voting_rule&#34;, &#34;TEXT&#34;),
                        (&#34;score&#34;, &#34;REAL&#34;),
                    },
                    &#34;condorcet_duels&#34;: {
                        (&#34;winner_id&#34;, &#34;INTEGER&#34;),
                        (&#34;loser_id&#34;, &#34;INTEGER&#34;),
                        (&#34;score&#34;, &#34;REAL&#34;),
                    },
                },
            )
            if missing:
                return False, f&#34;Database does not correspond&#34;

            cls._import_condorcet(connection, assoc)

        return True, &#34;Data imported&#34;

    @classmethod
    def _import_one_round(cls, connection: Connection, assoc: Dict[int, Candidate]) -&gt; None:
        &#34;&#34;&#34;Import results of one round voting rules to the election. Fill only candidates scores. 
        The rankings (an attribute `results` dans `electoral_systems.election.Election`) are not filled.


        Args:
            connection (sqlite3.Connection): SQLite connection.
            assoc (Dict[int, people.candidate.Candidate]): A dictionary associating each candidate ID
                (ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.
        &#34;&#34;&#34;

        cursor = connection.cursor()

        query = &#34;SELECT * FROM results_one_round&#34;
        cursor.execute(query)
        data = cursor.fetchall()

        for candidate_id, voting_rule, score in data:
            candidate = assoc[candidate_id]
            candidate.scores[voting_rule] = int(score)

    @classmethod
    def _import_multi_round(cls, connection: Connection, assoc: Dict[int, int]) -&gt; None:
        &#34;&#34;&#34;Import results of multi-round voting rules to the election. Fill only candidates scores. 
        The rankings (an attribute `results` in `electoral_systems.election.Election`) are not filled.

        Args:
            connection (sqlite3.Connection): SQLite connection.
            assoc (Dict[int, people.candidate.Candidate]): A dictionary associating each candidate ID
                (ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.
        &#34;&#34;&#34;

        cursor = connection.cursor()

        # Init lists based on length
        cursor.execute(
            &#34;SELECT max(round), voting_rule FROM results_multi_round GROUP BY voting_rule&#34;)

        nb_rounds = cursor.fetchall()
        for rounds, voting_rule in nb_rounds:
            for candidate in assoc.values():
                candidate.scores[voting_rule] = [0] * (rounds + 1)

        cursor.execute(&#34;SELECT * FROM results_multi_round&#34;)
        data = cursor.fetchall()
        for candidate_id, voting_rule, round, score in data:
            candidate = assoc[candidate_id]
            candidate.scores[voting_rule][round] = int(score)

    @classmethod
    def _import_condorcet(cls, connection: Connection, assoc: Dict[int, int]) -&gt; None:
        &#34;&#34;&#34;Import results of Condorcet-based voting rules to the election. Fill only candidates scores.
        The ranking (an attribute `results` in `electoral_systems.election.Election`) are not filled.
        Fill results of duels between candidates (un attribute `duels_scores` in `electoral_systems.election.Election`).

        Args:
            connection (sqlite3.Connection): SQLite connection.
            assoc (Dict[int, people.candidate.Candidate]): A dictionary associating each candidate ID
                (ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.
        &#34;&#34;&#34;

        cursor = connection.cursor()
        # Duels
        cursor.execute(&#34;SELECT * FROM condorcet_duels&#34;)
        data = cursor.fetchall()

        for winner_id, loser_id, score in data:
            winner = assoc[winner_id]
            loser = assoc[loser_id]
            cls.election.duels_scores[(winner, loser)] = int(score)

        # Scores
        cursor.execute(&#34;SELECT * FROM results_condorcet&#34;)
        data = cursor.fetchall()

        for candidate_id, voting_rule, score in data:
            candidate = assoc[candidate_id]
            if voting_rule == VotingRulesConstants.CONDORCET:
                candidate.scores[voting_rule] = score
            else:
                candidate.scores[voting_rule] = int(score)

    @classmethod
    def _import_config(cls, connection: Connection, table_missing: bool) -&gt; None:
        &#34;&#34;&#34;Import settings to the election, i.e. if  
            - the tie-break by duels was activated  
            - the liquid democracy was activated

        If the table `settings` does not exist in database, desactivate the liquid democracy and the tie-break by duels.

        Args:
            connection (sqlite3.Connection): SQLite connection.
            table_missing (bool): `True` if the table `settings` does not exist in the database, `False` otherwise.
        &#34;&#34;&#34;

        cls.election.liquid_democracy_activated = False
        cls.election.tie_breaker_activated = False

        if table_missing:
            return

        cursor = connection.cursor()

        cursor.execute(&#34;SELECT * FROM settings&#34;)
        data = cursor.fetchall()

        for parameter, set_value in data:
            match parameter:
                case &#34;liquid_democracy_activated&#34;:
                    cls.election.liquid_democracy_activated = bool(set_value)
                case &#34;tie_breaker_activated&#34;:
                    cls.election.tie_breaker_activated = bool(set_value)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sqlite.import_data.ImportData"><code class="flex name class">
<span>class <span class="ident">ImportData</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class which provides functionnality for data import. SQLite3 is used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImportData:
    &#34;&#34;&#34;A class which provides functionnality for data import. SQLite3 is used.&#34;&#34;&#34;

    election: Election = Election()
    IMPORT: str = &#34;I&#34;

    @classmethod
    def _check_tables(cls, tables_to_check: Set[str], existing_tables: Set[str]) -&gt; tuple[bool, Set[str]]:
        &#34;&#34;&#34;Verify if tables in `tables_to_check` exist in database. Tables in database are listed in `existing_tables`.

        Args:
            tables_to_check (Set[str]): Table names whose existence should be verified.
            existing_tables (Set[str]): Table names that exist in database.

        Returns:
            tuple[bool, Set[str]]: A bool `True` if at least one table is missing in database and a set of missing table names.
                Otherwise, a bool `False` if all tables exist in DB, a set is empty in that case.
        &#34;&#34;&#34;

        missing_tables = tables_to_check - (tables_to_check &amp; existing_tables)
        return (bool(missing_tables), missing_tables)

    @classmethod
    def _get_existing_tables(cls, connection: Connection) -&gt; Set[str]:
        &#34;&#34;&#34;Get names of all existing tables in database. 

        Args:
            connection (sqlite3.Connection): SQLite connection.

        Returns:
            Set[str]: A set of table names.
        &#34;&#34;&#34;

        cursor = connection.cursor()
        cursor.execute(&#34;SELECT name FROM sqlite_master WHERE type = &#39;table&#39;&#34;)
        return {row[0] for row in cursor.fetchall()}

    @classmethod
    def _check_columns(cls, connection: Connection, tables_cols: Dict[str, tuple[str, str]]) -&gt; bool:
        &#34;&#34;&#34;Verify column names and their type affinity.

        Args:
            connection (sqlite3.Connection): SQLite connection.
            tables_cols (Dict[str, tuple[str, str]]): A dictionary whose keys are table names (existing in database),
                and values are column names ant type affinity which should be verified.

        Returns:
            bool: `True` if every table all specified columns with the correct type affinity. `False` otherwise.
        &#34;&#34;&#34;

        cursor = connection.cursor()
        for table, columns in tables_cols.items():
            cursor.execute(
                f&#34;SELECT name, type FROM pragma_table_info(&#39;{table}&#39;)&#34;)
            existing_columns = {(row[0], row[1]) for row in cursor.fetchall()}
            missing_columns = columns - (columns &amp; existing_columns)
            if missing_columns:
                return True
        return False

    @classmethod
    def _check_columns_people(cls, connection: Connection) -&gt; bool:
        &#34;&#34;&#34;Verify column names and their type affinity in tables for electors and candidates.

        Args:
            connection (sqlite3.Connection): SQLite connection.

        Returns:
            bool: `True` if every table has all necessary columns with the correct type affinity. 
        &#34;&#34;&#34;

        return cls._check_columns(
            connection,
            {
                &#34;candidates&#34;: {
                    (&#34;id&#34;, &#34;INTEGER&#34;),
                    (&#34;x&#34;, &#34;REAL&#34;),
                    (&#34;y&#34;, &#34;REAL&#34;),
                    (&#34;first_name&#34;, &#34;TEXT&#34;),
                    (&#34;last_name&#34;, &#34;TEXT&#34;),
                    (&#34;dogmatism&#34;, &#34;REAL&#34;),
                    (&#34;opposition&#34;, &#34;REAL&#34;),
                },
                &#34;electors&#34;: {
                    (&#34;id&#34;, &#34;INTEGER&#34;),
                    (&#34;x&#34;, &#34;REAL&#34;),
                    (&#34;y&#34;, &#34;REAL&#34;),
                    (&#34;weight&#34;, &#34;INTEGER&#34;),
                    (&#34;knowledge&#34;, &#34;REAL&#34;),
                },
            },
        )

    @classmethod
    def import_people(cls, connection: Connection, with_results: bool) -&gt; tuple[bool, str]:
        &#34;&#34;&#34;Import data to the election from the database. Electors and candidates data are imported in any case. 
        Results data are imported only if necessary. Make all necessary verification on tables and its columns.

        Args:
            connection (sqlite3.Connection): SQLite connection.
            with_results (bool): `True` is results should be imported. `False`, otherwise.

        Returns:
            tuple[bool, str]: Un booléen `True` si les données ont été importées avec succès, `False` si l&#39;erreur est survenue.
                Une chaîne de caractères avec le message.
        &#34;&#34;&#34;

        if with_results:
            return cls.import_people_with_results(connection)
        return cls.import_people_no_results(connection)

    @classmethod
    def import_people_no_results(cls, connection: Connection) -&gt; tuple[bool, str]:
        &#34;&#34;&#34;Import data (candidates, electors only) in the election from the database.
        Make necessary verifications on tables and columns.

        Args:
            connection (sqlite3.Connection): SQLite connection.

        Returns:
            tuple[bool, str]: A bool `True` if data was imported succesfully, `False` if an error occurred.
                A string with message.
        &#34;&#34;&#34;

        existing_tables = cls._get_existing_tables(connection)
        # Check tables
        missing, missing_tables = cls._check_tables(
            {&#34;candidates&#34;, &#34;electors&#34;}, existing_tables
        )
        if missing:
            return False, f&#34;Tables {missing_tables} are not found&#34;

        # Check columns
        missing = cls._check_columns_people(connection)

        if missing:
            return False, f&#34;Database does not correspond&#34;

        cursor = connection.cursor()

        cursor.execute(&#34;SELECT x, y, first_name, last_name FROM candidates&#34;)
        candidates_data = cursor.fetchall()
       
        for x, y, first_name, last_name in candidates_data:
            id = next(cls.election.id_iter)
            cls.election.add_candidate_import(
                Candidate(
                    id=id, position=(
                        x, y), first_name=first_name, last_name=last_name
                )
            )

        cursor.execute(&#34;SELECT x, y, weight, knowledge FROM electors&#34;)
        electors_data = cursor.fetchall()

        for x, y, weight, knowledge in electors_data:
            id = next(cls.election.id_iter)
            cls.election.add_elector_import(
                Elector(id=id, position=(x, y),
                        weight=weight, knowledge=knowledge)
            )
        return True, &#34;Data imported&#34;

    @classmethod
    def import_people_with_results(cls, connection: Connection) -&gt; tuple[bool, str]:
        &#34;&#34;&#34;Import data (candidates, electors, results) to the election from the database. Make necessary verification on 
        tables and its columns. Import election settings if such table exists. Delete all existing data in the election.

        Args:
            connection (sqlite3.Connection): SQLite connection.

        Returns:
            tuple[bool, str]: A bool `True` if data was imported succesfully, `False` if an error occurred.
                A string with message.
        &#34;&#34;&#34;

        cls.election.delete_all_data()
        cls.election.nb_polls = 0
        # Check tables
        existing_tables = cls._get_existing_tables(connection)
        missing, missing_tables = cls._check_tables(
            {&#34;candidates&#34;, &#34;electors&#34;}, existing_tables
        )
        if missing:
            return False, f&#34;Tables {missing_tables} are not found&#34;

        # Check columns
        missing = cls._check_columns_people(connection)
        if missing:
            return False, f&#34;Database does not correspond&#34;

        cursor = connection.cursor()

        cursor.execute(&#34;SELECT * FROM candidates&#34;)
        candidates_data = cursor.fetchall()

        # id : candidate
        candidates_id_assoc = dict()

        for id, x, y, first_name, last_name, dogm, oppos in candidates_data:
            new_candidate = Candidate(
                id=next(cls.election.id_iter),
                position=(x, y),
                first_name=first_name,
                last_name=last_name,
                dogmatism=dogm,
                opposition=oppos,
            )
            cls.election.add_candidate_import(new_candidate)
            candidates_id_assoc[id] = new_candidate

        cursor.execute(&#34;SELECT * FROM electors&#34;)
        electors_data = cursor.fetchall()

        for id, x, y, weight, knowledge in electors_data:
            new_elector = Elector(
                id=id,
                position=(x, y),
                weight=weight,
                knowledge=knowledge,
            )
            cls.election.add_elector_import(new_elector)

        table_missing, _ = cls._check_tables({&#34;settings&#34;}, existing_tables)
        cls._import_config(connection, table_missing)
        return cls._import_results(connection, existing_tables, candidates_id_assoc)

    @classmethod
    def _import_results(cls, connection: Connection, existing_tables: Set[str], assoc: Dict[int, Candidate]) -&gt; tuple[bool, str]:
        &#34;&#34;&#34;Import results of each voting rule existing in the database to the election. 
        Make necessary verifications on tables and its columns. 

        Args:
            connection (sqlite3.Connection): SQLite connection.
            existing_tables (Set[str]): A set of names of tables existing in database.
            assoc (Dict[int, people.candidate.Candidate]): A dictionary associating each candidate ID
                (ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.

        Returns:
            tuple[bool, str]: A bool `True` if data was imported succesfully, `False` if an error occurred.
                A string with message.
        &#34;&#34;&#34;

        _, missing_tables = cls._check_tables(
            {&#34;results_one_round&#34;, &#34;results_multi_round&#34;, &#34;results_condorcet&#34;},
            existing_tables,
        )

        if len(missing_tables) == 3:
            return False, &#34;No tables related to scores found&#34;

        if &#34;results_one_round&#34; in existing_tables:
            # Check columns
            missing = cls._check_columns(
                connection,
                {
                    &#34;results_one_round&#34;: {
                        (&#34;candidate_id&#34;, &#34;INTEGER&#34;),
                        (&#34;voting_rule&#34;, &#34;TEXT&#34;),
                        (&#34;score&#34;, &#34;REAL&#34;),
                    },
                },
            )
            if missing:
                return False, f&#34;Database does not correspond&#34;

            cls._import_one_round(connection, assoc)

        if &#34;results_multi_round&#34; in existing_tables:
            missing = cls._check_columns(
                connection,
                {
                    &#34;results_multi_round&#34;: {
                        (&#34;candidate_id&#34;, &#34;INTEGER&#34;),
                        (&#34;voting_rule&#34;, &#34;TEXT&#34;),
                        (&#34;round&#34;, &#34;INTEGER&#34;),
                        (&#34;score&#34;, &#34;REAL&#34;),
                    },
                },
            )
            if missing:
                return False, f&#34;Database does not correspond&#34;
            cls._import_multi_round(connection, assoc)

        if (&#34;results_condorcet&#34; in existing_tables and &#34;condorcet_duels&#34; in existing_tables):
            missing = cls._check_columns(
                connection,
                {
                    &#34;results_condorcet&#34;: {
                        (&#34;candidate_id&#34;, &#34;INTEGER&#34;),
                        (&#34;voting_rule&#34;, &#34;TEXT&#34;),
                        (&#34;score&#34;, &#34;REAL&#34;),
                    },
                    &#34;condorcet_duels&#34;: {
                        (&#34;winner_id&#34;, &#34;INTEGER&#34;),
                        (&#34;loser_id&#34;, &#34;INTEGER&#34;),
                        (&#34;score&#34;, &#34;REAL&#34;),
                    },
                },
            )
            if missing:
                return False, f&#34;Database does not correspond&#34;

            cls._import_condorcet(connection, assoc)

        return True, &#34;Data imported&#34;

    @classmethod
    def _import_one_round(cls, connection: Connection, assoc: Dict[int, Candidate]) -&gt; None:
        &#34;&#34;&#34;Import results of one round voting rules to the election. Fill only candidates scores. 
        The rankings (an attribute `results` dans `electoral_systems.election.Election`) are not filled.


        Args:
            connection (sqlite3.Connection): SQLite connection.
            assoc (Dict[int, people.candidate.Candidate]): A dictionary associating each candidate ID
                (ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.
        &#34;&#34;&#34;

        cursor = connection.cursor()

        query = &#34;SELECT * FROM results_one_round&#34;
        cursor.execute(query)
        data = cursor.fetchall()

        for candidate_id, voting_rule, score in data:
            candidate = assoc[candidate_id]
            candidate.scores[voting_rule] = int(score)

    @classmethod
    def _import_multi_round(cls, connection: Connection, assoc: Dict[int, int]) -&gt; None:
        &#34;&#34;&#34;Import results of multi-round voting rules to the election. Fill only candidates scores. 
        The rankings (an attribute `results` in `electoral_systems.election.Election`) are not filled.

        Args:
            connection (sqlite3.Connection): SQLite connection.
            assoc (Dict[int, people.candidate.Candidate]): A dictionary associating each candidate ID
                (ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.
        &#34;&#34;&#34;

        cursor = connection.cursor()

        # Init lists based on length
        cursor.execute(
            &#34;SELECT max(round), voting_rule FROM results_multi_round GROUP BY voting_rule&#34;)

        nb_rounds = cursor.fetchall()
        for rounds, voting_rule in nb_rounds:
            for candidate in assoc.values():
                candidate.scores[voting_rule] = [0] * (rounds + 1)

        cursor.execute(&#34;SELECT * FROM results_multi_round&#34;)
        data = cursor.fetchall()
        for candidate_id, voting_rule, round, score in data:
            candidate = assoc[candidate_id]
            candidate.scores[voting_rule][round] = int(score)

    @classmethod
    def _import_condorcet(cls, connection: Connection, assoc: Dict[int, int]) -&gt; None:
        &#34;&#34;&#34;Import results of Condorcet-based voting rules to the election. Fill only candidates scores.
        The ranking (an attribute `results` in `electoral_systems.election.Election`) are not filled.
        Fill results of duels between candidates (un attribute `duels_scores` in `electoral_systems.election.Election`).

        Args:
            connection (sqlite3.Connection): SQLite connection.
            assoc (Dict[int, people.candidate.Candidate]): A dictionary associating each candidate ID
                (ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.
        &#34;&#34;&#34;

        cursor = connection.cursor()
        # Duels
        cursor.execute(&#34;SELECT * FROM condorcet_duels&#34;)
        data = cursor.fetchall()

        for winner_id, loser_id, score in data:
            winner = assoc[winner_id]
            loser = assoc[loser_id]
            cls.election.duels_scores[(winner, loser)] = int(score)

        # Scores
        cursor.execute(&#34;SELECT * FROM results_condorcet&#34;)
        data = cursor.fetchall()

        for candidate_id, voting_rule, score in data:
            candidate = assoc[candidate_id]
            if voting_rule == VotingRulesConstants.CONDORCET:
                candidate.scores[voting_rule] = score
            else:
                candidate.scores[voting_rule] = int(score)

    @classmethod
    def _import_config(cls, connection: Connection, table_missing: bool) -&gt; None:
        &#34;&#34;&#34;Import settings to the election, i.e. if  
            - the tie-break by duels was activated  
            - the liquid democracy was activated

        If the table `settings` does not exist in database, desactivate the liquid democracy and the tie-break by duels.

        Args:
            connection (sqlite3.Connection): SQLite connection.
            table_missing (bool): `True` if the table `settings` does not exist in the database, `False` otherwise.
        &#34;&#34;&#34;

        cls.election.liquid_democracy_activated = False
        cls.election.tie_breaker_activated = False

        if table_missing:
            return

        cursor = connection.cursor()

        cursor.execute(&#34;SELECT * FROM settings&#34;)
        data = cursor.fetchall()

        for parameter, set_value in data:
            match parameter:
                case &#34;liquid_democracy_activated&#34;:
                    cls.election.liquid_democracy_activated = bool(set_value)
                case &#34;tie_breaker_activated&#34;:
                    cls.election.tie_breaker_activated = bool(set_value)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="sqlite.import_data.ImportData.IMPORT"><code class="name">var <span class="ident">IMPORT</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sqlite.import_data.ImportData.election"><code class="name">var <span class="ident">election</span> : electoral_systems.election.Election</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sqlite.import_data.ImportData._check_columns"><code class="name flex">
<span>def <span class="ident">_check_columns</span></span>(<span>connection: sqlite3.Connection, tables_cols: Dict[str, tuple[str, str]]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Verify column names and their type affinity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong> :&ensp;<code>sqlite3.Connection</code></dt>
<dd>SQLite connection.</dd>
<dt><strong><code>tables_cols</code></strong> :&ensp;<code>Dict[str, tuple[str, str]]</code></dt>
<dd>A dictionary whose keys are table names (existing in database),
and values are column names ant type affinity which should be verified.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if every table all specified columns with the correct type affinity. <code>False</code> otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def _check_columns(cls, connection: Connection, tables_cols: Dict[str, tuple[str, str]]) -&gt; bool:
    &#34;&#34;&#34;Verify column names and their type affinity.

    Args:
        connection (sqlite3.Connection): SQLite connection.
        tables_cols (Dict[str, tuple[str, str]]): A dictionary whose keys are table names (existing in database),
            and values are column names ant type affinity which should be verified.

    Returns:
        bool: `True` if every table all specified columns with the correct type affinity. `False` otherwise.
    &#34;&#34;&#34;

    cursor = connection.cursor()
    for table, columns in tables_cols.items():
        cursor.execute(
            f&#34;SELECT name, type FROM pragma_table_info(&#39;{table}&#39;)&#34;)
        existing_columns = {(row[0], row[1]) for row in cursor.fetchall()}
        missing_columns = columns - (columns &amp; existing_columns)
        if missing_columns:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="sqlite.import_data.ImportData._check_columns_people"><code class="name flex">
<span>def <span class="ident">_check_columns_people</span></span>(<span>connection: sqlite3.Connection) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Verify column names and their type affinity in tables for electors and candidates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong> :&ensp;<code>sqlite3.Connection</code></dt>
<dd>SQLite connection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if every table has all necessary columns with the correct type affinity.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def _check_columns_people(cls, connection: Connection) -&gt; bool:
    &#34;&#34;&#34;Verify column names and their type affinity in tables for electors and candidates.

    Args:
        connection (sqlite3.Connection): SQLite connection.

    Returns:
        bool: `True` if every table has all necessary columns with the correct type affinity. 
    &#34;&#34;&#34;

    return cls._check_columns(
        connection,
        {
            &#34;candidates&#34;: {
                (&#34;id&#34;, &#34;INTEGER&#34;),
                (&#34;x&#34;, &#34;REAL&#34;),
                (&#34;y&#34;, &#34;REAL&#34;),
                (&#34;first_name&#34;, &#34;TEXT&#34;),
                (&#34;last_name&#34;, &#34;TEXT&#34;),
                (&#34;dogmatism&#34;, &#34;REAL&#34;),
                (&#34;opposition&#34;, &#34;REAL&#34;),
            },
            &#34;electors&#34;: {
                (&#34;id&#34;, &#34;INTEGER&#34;),
                (&#34;x&#34;, &#34;REAL&#34;),
                (&#34;y&#34;, &#34;REAL&#34;),
                (&#34;weight&#34;, &#34;INTEGER&#34;),
                (&#34;knowledge&#34;, &#34;REAL&#34;),
            },
        },
    )</code></pre>
</details>
</dd>
<dt id="sqlite.import_data.ImportData._check_tables"><code class="name flex">
<span>def <span class="ident">_check_tables</span></span>(<span>tables_to_check: Set[str], existing_tables: Set[str]) ‑> tuple[bool, typing.Set[str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Verify if tables in <code>tables_to_check</code> exist in database. Tables in database are listed in <code>existing_tables</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tables_to_check</code></strong> :&ensp;<code>Set[str]</code></dt>
<dd>Table names whose existence should be verified.</dd>
<dt><strong><code>existing_tables</code></strong> :&ensp;<code>Set[str]</code></dt>
<dd>Table names that exist in database.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[bool, Set[str]]</code></dt>
<dd>A bool <code>True</code> if at least one table is missing in database and a set of missing table names.
Otherwise, a bool <code>False</code> if all tables exist in DB, a set is empty in that case.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def _check_tables(cls, tables_to_check: Set[str], existing_tables: Set[str]) -&gt; tuple[bool, Set[str]]:
    &#34;&#34;&#34;Verify if tables in `tables_to_check` exist in database. Tables in database are listed in `existing_tables`.

    Args:
        tables_to_check (Set[str]): Table names whose existence should be verified.
        existing_tables (Set[str]): Table names that exist in database.

    Returns:
        tuple[bool, Set[str]]: A bool `True` if at least one table is missing in database and a set of missing table names.
            Otherwise, a bool `False` if all tables exist in DB, a set is empty in that case.
    &#34;&#34;&#34;

    missing_tables = tables_to_check - (tables_to_check &amp; existing_tables)
    return (bool(missing_tables), missing_tables)</code></pre>
</details>
</dd>
<dt id="sqlite.import_data.ImportData._get_existing_tables"><code class="name flex">
<span>def <span class="ident">_get_existing_tables</span></span>(<span>connection: sqlite3.Connection) ‑> Set[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get names of all existing tables in database. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong> :&ensp;<code>sqlite3.Connection</code></dt>
<dd>SQLite connection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Set[str]</code></dt>
<dd>A set of table names.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def _get_existing_tables(cls, connection: Connection) -&gt; Set[str]:
    &#34;&#34;&#34;Get names of all existing tables in database. 

    Args:
        connection (sqlite3.Connection): SQLite connection.

    Returns:
        Set[str]: A set of table names.
    &#34;&#34;&#34;

    cursor = connection.cursor()
    cursor.execute(&#34;SELECT name FROM sqlite_master WHERE type = &#39;table&#39;&#34;)
    return {row[0] for row in cursor.fetchall()}</code></pre>
</details>
</dd>
<dt id="sqlite.import_data.ImportData._import_condorcet"><code class="name flex">
<span>def <span class="ident">_import_condorcet</span></span>(<span>connection: sqlite3.Connection, assoc: Dict[int, int]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Import results of Condorcet-based voting rules to the election. Fill only candidates scores.
The ranking (an attribute <code>results</code> in <code>electoral_systems.election.Election</code>) are not filled.
Fill results of duels between candidates (un attribute <code>duels_scores</code> in <code>electoral_systems.election.Election</code>).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong> :&ensp;<code>sqlite3.Connection</code></dt>
<dd>SQLite connection.</dd>
<dt><strong><code>assoc</code></strong> :&ensp;<code>Dict[int, people.candidate.Candidate]</code></dt>
<dd>A dictionary associating each candidate ID
(ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def _import_condorcet(cls, connection: Connection, assoc: Dict[int, int]) -&gt; None:
    &#34;&#34;&#34;Import results of Condorcet-based voting rules to the election. Fill only candidates scores.
    The ranking (an attribute `results` in `electoral_systems.election.Election`) are not filled.
    Fill results of duels between candidates (un attribute `duels_scores` in `electoral_systems.election.Election`).

    Args:
        connection (sqlite3.Connection): SQLite connection.
        assoc (Dict[int, people.candidate.Candidate]): A dictionary associating each candidate ID
            (ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.
    &#34;&#34;&#34;

    cursor = connection.cursor()
    # Duels
    cursor.execute(&#34;SELECT * FROM condorcet_duels&#34;)
    data = cursor.fetchall()

    for winner_id, loser_id, score in data:
        winner = assoc[winner_id]
        loser = assoc[loser_id]
        cls.election.duels_scores[(winner, loser)] = int(score)

    # Scores
    cursor.execute(&#34;SELECT * FROM results_condorcet&#34;)
    data = cursor.fetchall()

    for candidate_id, voting_rule, score in data:
        candidate = assoc[candidate_id]
        if voting_rule == VotingRulesConstants.CONDORCET:
            candidate.scores[voting_rule] = score
        else:
            candidate.scores[voting_rule] = int(score)</code></pre>
</details>
</dd>
<dt id="sqlite.import_data.ImportData._import_config"><code class="name flex">
<span>def <span class="ident">_import_config</span></span>(<span>connection: sqlite3.Connection, table_missing: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Import settings to the election, i.e. if<br>
- the tie-break by duels was activated<br>
- the liquid democracy was activated</p>
<p>If the table <code>settings</code> does not exist in database, desactivate the liquid democracy and the tie-break by duels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong> :&ensp;<code>sqlite3.Connection</code></dt>
<dd>SQLite connection.</dd>
<dt><strong><code>table_missing</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the table <code>settings</code> does not exist in the database, <code>False</code> otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def _import_config(cls, connection: Connection, table_missing: bool) -&gt; None:
    &#34;&#34;&#34;Import settings to the election, i.e. if  
        - the tie-break by duels was activated  
        - the liquid democracy was activated

    If the table `settings` does not exist in database, desactivate the liquid democracy and the tie-break by duels.

    Args:
        connection (sqlite3.Connection): SQLite connection.
        table_missing (bool): `True` if the table `settings` does not exist in the database, `False` otherwise.
    &#34;&#34;&#34;

    cls.election.liquid_democracy_activated = False
    cls.election.tie_breaker_activated = False

    if table_missing:
        return

    cursor = connection.cursor()

    cursor.execute(&#34;SELECT * FROM settings&#34;)
    data = cursor.fetchall()

    for parameter, set_value in data:
        match parameter:
            case &#34;liquid_democracy_activated&#34;:
                cls.election.liquid_democracy_activated = bool(set_value)
            case &#34;tie_breaker_activated&#34;:
                cls.election.tie_breaker_activated = bool(set_value)</code></pre>
</details>
</dd>
<dt id="sqlite.import_data.ImportData._import_multi_round"><code class="name flex">
<span>def <span class="ident">_import_multi_round</span></span>(<span>connection: sqlite3.Connection, assoc: Dict[int, int]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Import results of multi-round voting rules to the election. Fill only candidates scores.
The rankings (an attribute <code>results</code> in <code>electoral_systems.election.Election</code>) are not filled.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong> :&ensp;<code>sqlite3.Connection</code></dt>
<dd>SQLite connection.</dd>
<dt><strong><code>assoc</code></strong> :&ensp;<code>Dict[int, people.candidate.Candidate]</code></dt>
<dd>A dictionary associating each candidate ID
(ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def _import_multi_round(cls, connection: Connection, assoc: Dict[int, int]) -&gt; None:
    &#34;&#34;&#34;Import results of multi-round voting rules to the election. Fill only candidates scores. 
    The rankings (an attribute `results` in `electoral_systems.election.Election`) are not filled.

    Args:
        connection (sqlite3.Connection): SQLite connection.
        assoc (Dict[int, people.candidate.Candidate]): A dictionary associating each candidate ID
            (ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.
    &#34;&#34;&#34;

    cursor = connection.cursor()

    # Init lists based on length
    cursor.execute(
        &#34;SELECT max(round), voting_rule FROM results_multi_round GROUP BY voting_rule&#34;)

    nb_rounds = cursor.fetchall()
    for rounds, voting_rule in nb_rounds:
        for candidate in assoc.values():
            candidate.scores[voting_rule] = [0] * (rounds + 1)

    cursor.execute(&#34;SELECT * FROM results_multi_round&#34;)
    data = cursor.fetchall()
    for candidate_id, voting_rule, round, score in data:
        candidate = assoc[candidate_id]
        candidate.scores[voting_rule][round] = int(score)</code></pre>
</details>
</dd>
<dt id="sqlite.import_data.ImportData._import_one_round"><code class="name flex">
<span>def <span class="ident">_import_one_round</span></span>(<span>connection: sqlite3.Connection, assoc: Dict[int, people.candidate.Candidate]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Import results of one round voting rules to the election. Fill only candidates scores.
The rankings (an attribute <code>results</code> dans <code>electoral_systems.election.Election</code>) are not filled.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong> :&ensp;<code>sqlite3.Connection</code></dt>
<dd>SQLite connection.</dd>
<dt><strong><code>assoc</code></strong> :&ensp;<code>Dict[int, people.candidate.Candidate]</code></dt>
<dd>A dictionary associating each candidate ID
(ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def _import_one_round(cls, connection: Connection, assoc: Dict[int, Candidate]) -&gt; None:
    &#34;&#34;&#34;Import results of one round voting rules to the election. Fill only candidates scores. 
    The rankings (an attribute `results` dans `electoral_systems.election.Election`) are not filled.


    Args:
        connection (sqlite3.Connection): SQLite connection.
        assoc (Dict[int, people.candidate.Candidate]): A dictionary associating each candidate ID
            (ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.
    &#34;&#34;&#34;

    cursor = connection.cursor()

    query = &#34;SELECT * FROM results_one_round&#34;
    cursor.execute(query)
    data = cursor.fetchall()

    for candidate_id, voting_rule, score in data:
        candidate = assoc[candidate_id]
        candidate.scores[voting_rule] = int(score)</code></pre>
</details>
</dd>
<dt id="sqlite.import_data.ImportData._import_results"><code class="name flex">
<span>def <span class="ident">_import_results</span></span>(<span>connection: sqlite3.Connection, existing_tables: Set[str], assoc: Dict[int, people.candidate.Candidate]) ‑> tuple[bool, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Import results of each voting rule existing in the database to the election.
Make necessary verifications on tables and its columns. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong> :&ensp;<code>sqlite3.Connection</code></dt>
<dd>SQLite connection.</dd>
<dt><strong><code>existing_tables</code></strong> :&ensp;<code>Set[str]</code></dt>
<dd>A set of names of tables existing in database.</dd>
<dt><strong><code>assoc</code></strong> :&ensp;<code>Dict[int, people.candidate.Candidate]</code></dt>
<dd>A dictionary associating each candidate ID
(ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[bool, str]</code></dt>
<dd>A bool <code>True</code> if data was imported succesfully, <code>False</code> if an error occurred.
A string with message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def _import_results(cls, connection: Connection, existing_tables: Set[str], assoc: Dict[int, Candidate]) -&gt; tuple[bool, str]:
    &#34;&#34;&#34;Import results of each voting rule existing in the database to the election. 
    Make necessary verifications on tables and its columns. 

    Args:
        connection (sqlite3.Connection): SQLite connection.
        existing_tables (Set[str]): A set of names of tables existing in database.
        assoc (Dict[int, people.candidate.Candidate]): A dictionary associating each candidate ID
            (ID in database) a candidate in the election. Necessary because a there is a possiblity of divergence of these IDs.

    Returns:
        tuple[bool, str]: A bool `True` if data was imported succesfully, `False` if an error occurred.
            A string with message.
    &#34;&#34;&#34;

    _, missing_tables = cls._check_tables(
        {&#34;results_one_round&#34;, &#34;results_multi_round&#34;, &#34;results_condorcet&#34;},
        existing_tables,
    )

    if len(missing_tables) == 3:
        return False, &#34;No tables related to scores found&#34;

    if &#34;results_one_round&#34; in existing_tables:
        # Check columns
        missing = cls._check_columns(
            connection,
            {
                &#34;results_one_round&#34;: {
                    (&#34;candidate_id&#34;, &#34;INTEGER&#34;),
                    (&#34;voting_rule&#34;, &#34;TEXT&#34;),
                    (&#34;score&#34;, &#34;REAL&#34;),
                },
            },
        )
        if missing:
            return False, f&#34;Database does not correspond&#34;

        cls._import_one_round(connection, assoc)

    if &#34;results_multi_round&#34; in existing_tables:
        missing = cls._check_columns(
            connection,
            {
                &#34;results_multi_round&#34;: {
                    (&#34;candidate_id&#34;, &#34;INTEGER&#34;),
                    (&#34;voting_rule&#34;, &#34;TEXT&#34;),
                    (&#34;round&#34;, &#34;INTEGER&#34;),
                    (&#34;score&#34;, &#34;REAL&#34;),
                },
            },
        )
        if missing:
            return False, f&#34;Database does not correspond&#34;
        cls._import_multi_round(connection, assoc)

    if (&#34;results_condorcet&#34; in existing_tables and &#34;condorcet_duels&#34; in existing_tables):
        missing = cls._check_columns(
            connection,
            {
                &#34;results_condorcet&#34;: {
                    (&#34;candidate_id&#34;, &#34;INTEGER&#34;),
                    (&#34;voting_rule&#34;, &#34;TEXT&#34;),
                    (&#34;score&#34;, &#34;REAL&#34;),
                },
                &#34;condorcet_duels&#34;: {
                    (&#34;winner_id&#34;, &#34;INTEGER&#34;),
                    (&#34;loser_id&#34;, &#34;INTEGER&#34;),
                    (&#34;score&#34;, &#34;REAL&#34;),
                },
            },
        )
        if missing:
            return False, f&#34;Database does not correspond&#34;

        cls._import_condorcet(connection, assoc)

    return True, &#34;Data imported&#34;</code></pre>
</details>
</dd>
<dt id="sqlite.import_data.ImportData.import_people"><code class="name flex">
<span>def <span class="ident">import_people</span></span>(<span>connection: sqlite3.Connection, with_results: bool) ‑> tuple[bool, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Import data to the election from the database. Electors and candidates data are imported in any case.
Results data are imported only if necessary. Make all necessary verification on tables and its columns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong> :&ensp;<code>sqlite3.Connection</code></dt>
<dd>SQLite connection.</dd>
<dt><strong><code>with_results</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> is results should be imported. <code>False</code>, otherwise.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[bool, str]</code></dt>
<dd>Un booléen <code>True</code> si les données ont été importées avec succès, <code>False</code> si l'erreur est survenue.
Une chaîne de caractères avec le message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def import_people(cls, connection: Connection, with_results: bool) -&gt; tuple[bool, str]:
    &#34;&#34;&#34;Import data to the election from the database. Electors and candidates data are imported in any case. 
    Results data are imported only if necessary. Make all necessary verification on tables and its columns.

    Args:
        connection (sqlite3.Connection): SQLite connection.
        with_results (bool): `True` is results should be imported. `False`, otherwise.

    Returns:
        tuple[bool, str]: Un booléen `True` si les données ont été importées avec succès, `False` si l&#39;erreur est survenue.
            Une chaîne de caractères avec le message.
    &#34;&#34;&#34;

    if with_results:
        return cls.import_people_with_results(connection)
    return cls.import_people_no_results(connection)</code></pre>
</details>
</dd>
<dt id="sqlite.import_data.ImportData.import_people_no_results"><code class="name flex">
<span>def <span class="ident">import_people_no_results</span></span>(<span>connection: sqlite3.Connection) ‑> tuple[bool, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Import data (candidates, electors only) in the election from the database.
Make necessary verifications on tables and columns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong> :&ensp;<code>sqlite3.Connection</code></dt>
<dd>SQLite connection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[bool, str]</code></dt>
<dd>A bool <code>True</code> if data was imported succesfully, <code>False</code> if an error occurred.
A string with message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def import_people_no_results(cls, connection: Connection) -&gt; tuple[bool, str]:
    &#34;&#34;&#34;Import data (candidates, electors only) in the election from the database.
    Make necessary verifications on tables and columns.

    Args:
        connection (sqlite3.Connection): SQLite connection.

    Returns:
        tuple[bool, str]: A bool `True` if data was imported succesfully, `False` if an error occurred.
            A string with message.
    &#34;&#34;&#34;

    existing_tables = cls._get_existing_tables(connection)
    # Check tables
    missing, missing_tables = cls._check_tables(
        {&#34;candidates&#34;, &#34;electors&#34;}, existing_tables
    )
    if missing:
        return False, f&#34;Tables {missing_tables} are not found&#34;

    # Check columns
    missing = cls._check_columns_people(connection)

    if missing:
        return False, f&#34;Database does not correspond&#34;

    cursor = connection.cursor()

    cursor.execute(&#34;SELECT x, y, first_name, last_name FROM candidates&#34;)
    candidates_data = cursor.fetchall()
   
    for x, y, first_name, last_name in candidates_data:
        id = next(cls.election.id_iter)
        cls.election.add_candidate_import(
            Candidate(
                id=id, position=(
                    x, y), first_name=first_name, last_name=last_name
            )
        )

    cursor.execute(&#34;SELECT x, y, weight, knowledge FROM electors&#34;)
    electors_data = cursor.fetchall()

    for x, y, weight, knowledge in electors_data:
        id = next(cls.election.id_iter)
        cls.election.add_elector_import(
            Elector(id=id, position=(x, y),
                    weight=weight, knowledge=knowledge)
        )
    return True, &#34;Data imported&#34;</code></pre>
</details>
</dd>
<dt id="sqlite.import_data.ImportData.import_people_with_results"><code class="name flex">
<span>def <span class="ident">import_people_with_results</span></span>(<span>connection: sqlite3.Connection) ‑> tuple[bool, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Import data (candidates, electors, results) to the election from the database. Make necessary verification on
tables and its columns. Import election settings if such table exists. Delete all existing data in the election.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong> :&ensp;<code>sqlite3.Connection</code></dt>
<dd>SQLite connection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[bool, str]</code></dt>
<dd>A bool <code>True</code> if data was imported succesfully, <code>False</code> if an error occurred.
A string with message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def import_people_with_results(cls, connection: Connection) -&gt; tuple[bool, str]:
    &#34;&#34;&#34;Import data (candidates, electors, results) to the election from the database. Make necessary verification on 
    tables and its columns. Import election settings if such table exists. Delete all existing data in the election.

    Args:
        connection (sqlite3.Connection): SQLite connection.

    Returns:
        tuple[bool, str]: A bool `True` if data was imported succesfully, `False` if an error occurred.
            A string with message.
    &#34;&#34;&#34;

    cls.election.delete_all_data()
    cls.election.nb_polls = 0
    # Check tables
    existing_tables = cls._get_existing_tables(connection)
    missing, missing_tables = cls._check_tables(
        {&#34;candidates&#34;, &#34;electors&#34;}, existing_tables
    )
    if missing:
        return False, f&#34;Tables {missing_tables} are not found&#34;

    # Check columns
    missing = cls._check_columns_people(connection)
    if missing:
        return False, f&#34;Database does not correspond&#34;

    cursor = connection.cursor()

    cursor.execute(&#34;SELECT * FROM candidates&#34;)
    candidates_data = cursor.fetchall()

    # id : candidate
    candidates_id_assoc = dict()

    for id, x, y, first_name, last_name, dogm, oppos in candidates_data:
        new_candidate = Candidate(
            id=next(cls.election.id_iter),
            position=(x, y),
            first_name=first_name,
            last_name=last_name,
            dogmatism=dogm,
            opposition=oppos,
        )
        cls.election.add_candidate_import(new_candidate)
        candidates_id_assoc[id] = new_candidate

    cursor.execute(&#34;SELECT * FROM electors&#34;)
    electors_data = cursor.fetchall()

    for id, x, y, weight, knowledge in electors_data:
        new_elector = Elector(
            id=id,
            position=(x, y),
            weight=weight,
            knowledge=knowledge,
        )
        cls.election.add_elector_import(new_elector)

    table_missing, _ = cls._check_tables({&#34;settings&#34;}, existing_tables)
    cls._import_config(connection, table_missing)
    return cls._import_results(connection, existing_tables, candidates_id_assoc)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sqlite" href="index.html">sqlite</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sqlite.import_data.ImportData" href="#sqlite.import_data.ImportData">ImportData</a></code></h4>
<ul class="">
<li><code><a title="sqlite.import_data.ImportData.IMPORT" href="#sqlite.import_data.ImportData.IMPORT">IMPORT</a></code></li>
<li><code><a title="sqlite.import_data.ImportData._check_columns" href="#sqlite.import_data.ImportData._check_columns">_check_columns</a></code></li>
<li><code><a title="sqlite.import_data.ImportData._check_columns_people" href="#sqlite.import_data.ImportData._check_columns_people">_check_columns_people</a></code></li>
<li><code><a title="sqlite.import_data.ImportData._check_tables" href="#sqlite.import_data.ImportData._check_tables">_check_tables</a></code></li>
<li><code><a title="sqlite.import_data.ImportData._get_existing_tables" href="#sqlite.import_data.ImportData._get_existing_tables">_get_existing_tables</a></code></li>
<li><code><a title="sqlite.import_data.ImportData._import_condorcet" href="#sqlite.import_data.ImportData._import_condorcet">_import_condorcet</a></code></li>
<li><code><a title="sqlite.import_data.ImportData._import_config" href="#sqlite.import_data.ImportData._import_config">_import_config</a></code></li>
<li><code><a title="sqlite.import_data.ImportData._import_multi_round" href="#sqlite.import_data.ImportData._import_multi_round">_import_multi_round</a></code></li>
<li><code><a title="sqlite.import_data.ImportData._import_one_round" href="#sqlite.import_data.ImportData._import_one_round">_import_one_round</a></code></li>
<li><code><a title="sqlite.import_data.ImportData._import_results" href="#sqlite.import_data.ImportData._import_results">_import_results</a></code></li>
<li><code><a title="sqlite.import_data.ImportData.election" href="#sqlite.import_data.ImportData.election">election</a></code></li>
<li><code><a title="sqlite.import_data.ImportData.import_people" href="#sqlite.import_data.ImportData.import_people">import_people</a></code></li>
<li><code><a title="sqlite.import_data.ImportData.import_people_no_results" href="#sqlite.import_data.ImportData.import_people_no_results">import_people_no_results</a></code></li>
<li><code><a title="sqlite.import_data.ImportData.import_people_with_results" href="#sqlite.import_data.ImportData.import_people_with_results">import_people_with_results</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>