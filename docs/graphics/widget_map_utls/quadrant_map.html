<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>graphics.widget_map_utls.quadrant_map API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>graphics.widget_map_utls.quadrant_map</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from PySide6.QtWidgets import QWidget, QVBoxLayout, QLineEdit
from PySide6.QtGui import QPainter, QPen, QColor, QFont, QTransform, QColor, QPaintEvent, QMouseEvent
from PySide6.QtCore import Qt, QPointF, QPoint, QSize

from numpy import clip
from numpy.random import normal
from electoral_systems import Election, RandomConstants


class QuadrantMap(QWidget):
    &#34;&#34;&#34;Un widget qui représente la carte politique. La carte politique sera dessinée à l&#39;aide de `PySide6.QtGui.QPainter`.&#34;&#34;&#34;

    def __init__(self, size_proportion: float, parent: QWidget):
        &#34;&#34;&#34;Initialise une instance d&#39;élection (pour le partage des données).
        Fixe la taille. Initialise (mais n&#39;applique pas) une transformation des coordonnées.

        Args:
            size_proportion (float): Une proportion de la taille d&#39;un widget parent.
                La taille d&#39;un widget est fixé en fonction de cette proportion.
            parent (PySide6.QtWidgets.QWidget): Un parent d&#39;un widget.
        &#34;&#34;&#34;

        super().__init__(parent)

        self.election = Election()
        self.draw_delegations = False

        side_size = min(parent.width(), parent.height())
        self.setFixedSize(size_proportion * side_size, size_proportion * side_size)

        self.setTransformation()
        self.initUI()

    def setTransformation(self) -&gt; None:
        &#34;&#34;&#34;Initialise (mais n&#39;applique pas) la transformation des coordonnées de l&#39;ordinateur.
        But: avoir un système des coordonnées comme en maths.&#34;&#34;&#34;

        self.transform = QTransform()
        # L&#39;ordre a l&#39;importance!
        # Flip Y-axis
        self.transform.scale(1, -1)
        # Move center
        self.transform.translate(self.width() / 2, -self.height() / 2)

    def initUI(self):
        &#34;&#34;&#34;Initialise le layout. Changee la couleur d&#39;arrière-plan sur blanc. Initialise le step pour dessiner la grille.&#34;&#34;&#34;

        self.layout = QVBoxLayout(self)
        self.setPallete()

        self.grid_step = 20
        self.text_box_active = False

    def setPallete(self) -&gt; None:
        &#34;&#34;&#34;Change la couleur d&#39;arrière-plan sur blanc.&#34;&#34;&#34;

        self.setAutoFillBackground(True)
        pallete = self.palette()
        pallete.setColor(self.backgroundRole(), QColor(255, 255, 255))
        self.setPalette(pallete)

    def paintEvent(self, event: QPaintEvent) -&gt; None:
        &#34;&#34;&#34;Redéfinit `paintEvent` par défaut. Dessine la grille, les axes X, Y. Applique la transformation.
        Dessine les points correspondant aux positions des candidats et des électeurs.&#34;&#34;&#34;

        painter = QPainter(self)
        self.drawGrid(painter)
        self.drawAxes(painter)
        self.drawAxisLabels(painter)

        painter.setTransform(self.transform)

        if self.draw_delegations:
            self.drawElectorsDelegation(painter)
        else:
            self.drawPoints(painter)

    def drawGrid(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine la grille.

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        # Couleur gris clair
        pen = QPen(QColor(220, 220, 220))
        painter.setPen(pen)
        # nb_lines = nb_rows = nb_cols
        nb_lines = self.width() // self.grid_step

        for row in range(1, nb_lines + 1):
            # lignes verticales
            painter.drawLine(
                row * self.grid_step, 0, row * self.grid_step, self.height()
            )
            # lignes horizontales
            painter.drawLine(
                0, row * self.grid_step, self.width(), row * self.grid_step
            )

    def drawAxes(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine les axes X, Y.

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        # Couleur noire
        pen = QPen(QColor(0, 0, 0))
        pen.setWidth(2)

        # Width = height, donc suffisant
        central_line = self.width() // self.grid_step / 2
        painter.setPen(pen)
        # Axe x
        painter.drawLine(
            0,
            central_line * self.grid_step,
            self.width(),
            central_line * self.grid_step,
        )
        # Axe y
        painter.drawLine(
            central_line * self.grid_step,
            0,
            central_line * self.grid_step,
            self.height(),
        )

    def drawAxisLabels(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine les labels des axes.

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        # Couleur noire
        pen = QPen(QColor(0, 0, 0))
        painter.setPen(pen)
        # QFont permet de définir les propriétés de la police
        font = QFont()
        font.setFamily(&#34;Arial&#34;)
        font.setPointSize(10)
        # applique les propriétés du QFont au pinceau
        painter.setFont(font)

        painter.drawText(self.width() - 40, self.height() / 2 + 30, &#34;Right&#34;)
        painter.drawText(self.width() / 2 - 85, 20, &#34;Autoritarian&#34;)
        painter.drawText(self.width() / 150, self.height() / 2 + 30, &#34;Left&#34;)
        painter.drawText(self.width() / 2 - 60, self.height() - 10, &#34;Liberal&#34;)

    def drawElectors(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine les points correspondants aux positions des électeurs (sans la démocratie liquide).

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        # Couleur bleue standard
        pen = QPen(QColor(0, 0, 255))
        pen.setWidth(4)
        painter.setPen(pen)
        for elector in self.election.electors:
            painter.drawPoint(self.scaleCoordinates(elector.position))

    def drawCandidates(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine les points correspondants aux positions des candidats.

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        # Couleur rouge standard
        pen = QPen(QColor(255, 0, 0))
        pen.setWidth(4)
        painter.setPen(pen)
        for candidate in self.election.candidates:
            fst_name, lst_name = candidate.first_name, candidate.last_name
            # Reconfiguration du pinceau après une itération de la boucle
            point_scaled = self.scaleCoordinates(candidate.position)
            painter.setPen(pen)
            painter.drawPoint(point_scaled)

            # Reconfiguration du style du pinceau pour le texte
            painter.setPen(QColor(0, 0, 0))
            point_mapped = self.transform.map(point_scaled)
            # Pour empêcher l&#39;inversion du texte
            painter.setWorldMatrixEnabled(False)
            point_text = self.getTextPosition(point_mapped)
            painter.drawText(point_mapped + point_text, f&#34;{fst_name} {lst_name}&#34;)
            painter.setWorldMatrixEnabled(True)

    def drawPoints(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine les points correspondants aux positions des électeurs (sans la démocratie liquide)
        et aux positions des candidats.

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        self.drawElectors(painter)
        self.drawCandidates(painter)

    def drawElectorsDelegation(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine les points correspondants aux positions des électeurs (avec la démocratie liquide)
        i.e. avec les poids.

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        pen = QPen(QColor(128, 128, 128))
        pen.setWidth(4)
        painter.setPen(pen)
        for elector in self.election.electors:
            if elector.weight == 0:
                painter.drawPoint(self.scaleCoordinates(elector.position))

        for elector in self.election.electors:
            if elector.weight &gt; 0:
                pen3 = QPen(QColor(30, 144, 255))
                pen3.setWidth(4)
                painter.setPen(pen3)

                scaled_point = self.scaleCoordinates(elector.position)
                point_mapped = self.transform.map(scaled_point)

                painter.drawPoint(scaled_point)
                # Pour empêcher l&#39;inversion du texte
                painter.setWorldMatrixEnabled(False)
                point_text = self.getTextPosition(point_mapped)
                painter.drawText(point_mapped + point_text, f&#34;{elector.weight}&#34;)
                painter.setWorldMatrixEnabled(True)

        self.drawCandidates(painter)

    def scaleCoordinates(self, position: tuple[float, float]) -&gt; QPointF:
        &#34;&#34;&#34;Met les coordonnées normalisées à l&#39;échelle de la carte politique.

        Args:
            position (tuple[float, float]): Une position dont chaque coordonnée est normalisé.

        Returns:
            PySide6.QtCore.QPointF: Un point mis à l&#39;échelle.
        &#34;&#34;&#34;

        x, y = position
        return QPointF(x * self.width() / 2, y * self.height() / 2)

    def normalizeCoordinates(self, point: QPointF) -&gt; tuple[float, float]:
        &#34;&#34;&#34;Normalise chaque coordonnée du point.

        Args:
            point (PySide6.QtCore.QPointF): Un point mis à l&#39;échelle dans le système de coordonnées mathématique.

        Returns:
            position (tuple[float, float]): Une position dont chaque coordonnée est normalisé.
        &#34;&#34;&#34;

        return point.x() / self.width() * 2, point.y() / self.height() * 2

    def mousePressEvent(self, event: QMouseEvent) -&gt; None:
        &#34;&#34;&#34;Redéfinit `mousePressEvent` par défaut. Clique gauche: place un candidat manuellement en entrant son nom et prénom.
        Clique droite: place un électeur manuellement.&#34;&#34;&#34;

        inverted_transform, _ = self.transform.inverted()
        point_inv = inverted_transform.map(event.position())
        normalized_pos = self.normalizeCoordinates(point_inv)
        # Clique gauche
        if event.button() == Qt.LeftButton:
            self.election.add_elector(normalized_pos)
            self.update()

        # Clique droite
        if event.button() == Qt.RightButton and not self.text_box_active:
            # Création de la zone de texte
            self.createTextBox(event.position(), normalized_pos)
            self.text_box_active = True

    def createTextBox(self, point: QPointF, normalized_pos: tuple[float, float]) -&gt; None:
        &#34;&#34;&#34;Crée un textbox lors de la création manuelle d&#39;un candidat.

        Args:
            point (PySide6.QtCore.QPointF): Un point sur la carte politique (dans le système des coordonnées de l&#39;ordinateur).
            normalized_pos (tuple[float, float]): Une position du `point` mais normalisée et dans le système des coordonnées
                mathématique.
        &#34;&#34;&#34;

        # Création de la zone de texte
        self.text_box = QLineEdit(self)

        # Placement de la zone de texte à la position clique (avec décalage)
        self.text_box.move(self.getTextBoxPosition(point, self.text_box.size()))

        # Appelle de la fonction de création et de stockage du nom connecté avec la touche enter
        self.text_box.returnPressed.connect(lambda: self.storeName(normalized_pos))

        # Affiche la zone de texte la zone de texte
        self.text_box.show()

    def storeName(self, normalized_pos: tuple[float, float]) -&gt; None:
        &#34;&#34;&#34;Stocke le prénom et le nom d&#39;un candidat créé manuellement. Le nom et le prénom sont obligatoires.
        Crée un candidat, l&#39;ajoute dans l&#39;élection. Supprime le textbox. Redéssine la carte politique. 

        Args:
            normalized_pos (tuple[float, float]): Une position normalisée et dans le système des coordonnées mathématique.
        &#34;&#34;&#34;

        # Récupérer le texte
        full_name = self.text_box.text().strip().split(&#34; &#34;, 1)
        # Interdire la création de candidats avec uniquement le prénom
        if len(full_name) == 1:
            return
        first_name, last_name = tuple(full_name)

        self.election.add_candidate(normalized_pos, first_name, last_name)
        self.update()
        self.text_box_active = False
        # Supprime la zone de texte
        self.text_box.deleteLater()

    def getTextPosition(self, point: QPointF) -&gt; QPointF:
        &#34;&#34;&#34;Calcule les coordonnées du texte pour qu&#39;il ne sort pas en dehors de la carte politique.

        Args:
            point (PySide6.QtCore.QPointF): Un point dans le système des coordonnés de l&#39;ordinateur. Correpond au point d&#39;origine.

        Returns:
            PySide6.QtCore.QPointF: Un point qui correpond aux coordonnées du texte où il faudra le dessiner (i.e. c&#39;est un point
                déjà décalé à partir du `point`). C&#39;est le point dans le système des coordonnés de l&#39;ordinateur.
        &#34;&#34;&#34;

        point_text = QPoint(5, 15)
        shift = point + point_text

        # Over the map on X &amp; Y
        if shift.x() + 100 &gt; self.width() and shift.y() + 100 &gt; self.height():
            # Inverse, flip X &amp; Y
            point_text = QPointF(-point_text.y(), -point_text.x())
        # Over the map on X
        elif shift.x() + 100 &gt; self.width():
            point_text = QPointF(-point_text.x(), point_text.y())
        # Over the map on Y
        elif shift.y() + 100 &gt; self.height():
            point_text = QPointF(point_text.x(), -point_text.y())

        return point_text

    def getTextBoxPosition(self, point: QPointF, size: QSize) -&gt; QPoint:
        &#34;&#34;&#34;Calcule les coordonnées du textbox pour qu&#39;il ne sort pas en dehors de la carte politique.

        Args:
            point (PySide6.QtCore.QPointF): Un point dans le système des coordonnés de l&#39;ordinateur. Correpond au point d&#39;origine.
            size (PySide6.QtCore.QSize): La taille du textbox.

        Returns:
            PySide6.QtCore.QPoint: Un point qui correpond aux coordonnées du texte où il faudra le dessiner (i.e. c&#39;est un point
                déjà décalé à partir du `point`). C&#39;est le point dans le système des coordonnés de l&#39;ordinateur.
        &#34;&#34;&#34;

        width, height = size.width(), size.height()
        point_textbox = point.toPoint()
        if point.x() + width &gt; self.width():
            point_textbox = QPoint(point_textbox.x() - width, point_textbox.y())
        if point.y() + height &gt; self.height():
            point_textbox = QPoint(point_textbox.x(), point_textbox.y() - height)

        return point_textbox

    def generateCoordinate(self, mu: float, sigma: float, limit: float) -&gt; float:
        &#34;&#34;&#34;Génére une coordonnée (x ou y) selon la loi normale avec des paramètres `mu` et `sigma`.
        Borne la valeur absolue d&#39;une coordonnée généré entre `limit`.

        Args:
            mu (float): La moyenne de la distribution normale. 
            sigma (float): L&#39;écart type de la distribution normale. Un réel strictement positive.
            lower_limit (float): La limite inférieure et supérieur pour le coordonnée. 

        Returns:
            float: Un coordonnée généré et borné.
        &#34;&#34;&#34;

        coordinate = normal(mu, sigma)

        # Nombre max de regénération d&#39;un coordonnée. Sinon, la boucle très longue possible
        max_iterations = 5
        while abs(coordinate) &gt; limit and max_iterations:
            coordinate = normal(mu, sigma)
            max_iterations -= 1

        # Si la valeur regénérée est encore hors bornes
        coordinate = clip(coordinate, -1, 1)

        return coordinate

    def generatePosition(self) -&gt; tuple[float, float]:
        &#34;&#34;&#34;Génére une position sur la carte politique selon la loi normale.

        Returns:
            tuple[float, float]: Une position générée dont chaque coordonnée est normalisé et borné.  
        &#34;&#34;&#34;

        constants = self.election.generation_constants
        economical_constants = constants[RandomConstants.ECONOMICAL]
        social_constants = constants[RandomConstants.SOCIAL]
        coef_dir = constants[RandomConstants.ORIENTATION]

        mu, sigma = economical_constants[0], economical_constants[1]
        x = self.generateCoordinate(mu, sigma, limit=1)

        mu, sigma = coef_dir * x + social_constants[0], social_constants[1]
        y = self.generateCoordinate(mu, sigma, limit=1)
        return (x, y)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="graphics.widget_map_utls.quadrant_map.normal"><code class="name flex">
<span>def <span class="ident">normal</span></span>(<span>loc=0.0, scale=1.0, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw random samples from a normal (Gaussian) distribution.</p>
<p>The probability density function of the normal distribution, first
derived by De Moivre and 200 years later by both Gauss and Laplace
independently [2]_, is often called the bell curve because of
its characteristic shape (see the example below).</p>
<p>The normal distributions occurs often in nature.
For example, it
describes the commonly occurring distribution of samples influenced
by a large number of tiny, random disturbances, each with its own
unique distribution [2]_.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code>~numpy.random.Generator.normal</code>
method of a <code>~numpy.random.Generator</code> instance instead;
please see the :ref:<code>random-quick-start</code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loc</code></strong> :&ensp;<code>float</code> or <code>array_like</code> of <code>floats</code></dt>
<dd>Mean ("centre") of the distribution.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code> or <code>array_like</code> of <code>floats</code></dt>
<dd>Standard deviation (spread or "width") of the distribution. Must be
non-negative.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code> or <code>tuple</code> of <code>ints</code>, optional</dt>
<dd>Output shape.
If the given shape is, e.g., <code>(m, n, k)</code>, then
<code>m * n * k</code> samples are drawn.
If size is <code>None</code> (default),
a single value is returned if <code>loc</code> and <code>scale</code> are both scalars.
Otherwise, <code>np.broadcast(loc, scale).size</code> samples are drawn.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>ndarray</code> or <code>scalar</code></dt>
<dd>Drawn samples from the parameterized normal distribution.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>scipy.stats.norm</code></dt>
<dd>probability density function, distribution or cumulative density function, etc.</dd>
<dt><code>random.Generator.normal</code></dt>
<dd>which should be used for new code.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The probability density for the Gaussian distribution is</p>
<p>[ e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} }, ]
where :math:<code>\mu</code> is the mean and :math:<code>\sigma</code> the standard
deviation. The square of the standard deviation, :math:<code>\sigma^2</code>,
is called the variance.</p>
<p>The function has its peak at the mean, and its "spread" increases with
the standard deviation (the function reaches 0.607 times its maximum at
:math:<code>x + \sigma</code> and :math:<code>x - \sigma</code> [2]_).
This implies that
normal is more likely to return samples lying close to the mean, rather
than those far away.</p>
<h2 id="references">References</h2>
<p>.. [1] Wikipedia, "Normal distribution",
<a href="https://en.wikipedia.org/wiki/Normal_distribution">https://en.wikipedia.org/wiki/Normal_distribution</a>
.. [2] P. R. Peebles Jr., "Central Limit Theorem" in "Probability,
Random Variables and Random Signal Principles", 4th ed., 2001,
pp. 51, 51, 125.</p>
<h2 id="examples">Examples</h2>
<p>Draw samples from the distribution:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mu, sigma = 0, 0.1 # mean and standard deviation
&gt;&gt;&gt; s = np.random.normal(mu, sigma, 1000)
</code></pre>
<p>Verify the mean and the variance:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; abs(mu - np.mean(s))
0.0  # may vary
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; abs(sigma - np.std(s, ddof=1))
0.1  # may vary
</code></pre>
<p>Display the histogram of the samples, along with
the probability density function:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, density=True)
&gt;&gt;&gt; plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *
...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),
...          linewidth=2, color='r')
&gt;&gt;&gt; plt.show()
</code></pre>
<p>Two-by-four array of samples from the normal distribution with
mean 3 and standard deviation 2.5:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; np.random.normal(3, 2.5, size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
</code></pre></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap"><code class="flex name class">
<span>class <span class="ident">QuadrantMap</span></span>
<span>(</span><span>size_proportion: float, parent: PySide6.QtWidgets.QWidget)</span>
</code></dt>
<dd>
<div class="desc"><p>Un widget qui représente la carte politique. La carte politique sera dessinée à l'aide de <code>PySide6.QtGui.QPainter</code>.</p>
<p>Initialise une instance d'élection (pour le partage des données).
Fixe la taille. Initialise (mais n'applique pas) une transformation des coordonnées.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size_proportion</code></strong> :&ensp;<code>float</code></dt>
<dd>Une proportion de la taille d'un widget parent.
La taille d'un widget est fixé en fonction de cette proportion.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>PySide6.QtWidgets.QWidget</code></dt>
<dd>Un parent d'un widget.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuadrantMap(QWidget):
    &#34;&#34;&#34;Un widget qui représente la carte politique. La carte politique sera dessinée à l&#39;aide de `PySide6.QtGui.QPainter`.&#34;&#34;&#34;

    def __init__(self, size_proportion: float, parent: QWidget):
        &#34;&#34;&#34;Initialise une instance d&#39;élection (pour le partage des données).
        Fixe la taille. Initialise (mais n&#39;applique pas) une transformation des coordonnées.

        Args:
            size_proportion (float): Une proportion de la taille d&#39;un widget parent.
                La taille d&#39;un widget est fixé en fonction de cette proportion.
            parent (PySide6.QtWidgets.QWidget): Un parent d&#39;un widget.
        &#34;&#34;&#34;

        super().__init__(parent)

        self.election = Election()
        self.draw_delegations = False

        side_size = min(parent.width(), parent.height())
        self.setFixedSize(size_proportion * side_size, size_proportion * side_size)

        self.setTransformation()
        self.initUI()

    def setTransformation(self) -&gt; None:
        &#34;&#34;&#34;Initialise (mais n&#39;applique pas) la transformation des coordonnées de l&#39;ordinateur.
        But: avoir un système des coordonnées comme en maths.&#34;&#34;&#34;

        self.transform = QTransform()
        # L&#39;ordre a l&#39;importance!
        # Flip Y-axis
        self.transform.scale(1, -1)
        # Move center
        self.transform.translate(self.width() / 2, -self.height() / 2)

    def initUI(self):
        &#34;&#34;&#34;Initialise le layout. Changee la couleur d&#39;arrière-plan sur blanc. Initialise le step pour dessiner la grille.&#34;&#34;&#34;

        self.layout = QVBoxLayout(self)
        self.setPallete()

        self.grid_step = 20
        self.text_box_active = False

    def setPallete(self) -&gt; None:
        &#34;&#34;&#34;Change la couleur d&#39;arrière-plan sur blanc.&#34;&#34;&#34;

        self.setAutoFillBackground(True)
        pallete = self.palette()
        pallete.setColor(self.backgroundRole(), QColor(255, 255, 255))
        self.setPalette(pallete)

    def paintEvent(self, event: QPaintEvent) -&gt; None:
        &#34;&#34;&#34;Redéfinit `paintEvent` par défaut. Dessine la grille, les axes X, Y. Applique la transformation.
        Dessine les points correspondant aux positions des candidats et des électeurs.&#34;&#34;&#34;

        painter = QPainter(self)
        self.drawGrid(painter)
        self.drawAxes(painter)
        self.drawAxisLabels(painter)

        painter.setTransform(self.transform)

        if self.draw_delegations:
            self.drawElectorsDelegation(painter)
        else:
            self.drawPoints(painter)

    def drawGrid(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine la grille.

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        # Couleur gris clair
        pen = QPen(QColor(220, 220, 220))
        painter.setPen(pen)
        # nb_lines = nb_rows = nb_cols
        nb_lines = self.width() // self.grid_step

        for row in range(1, nb_lines + 1):
            # lignes verticales
            painter.drawLine(
                row * self.grid_step, 0, row * self.grid_step, self.height()
            )
            # lignes horizontales
            painter.drawLine(
                0, row * self.grid_step, self.width(), row * self.grid_step
            )

    def drawAxes(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine les axes X, Y.

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        # Couleur noire
        pen = QPen(QColor(0, 0, 0))
        pen.setWidth(2)

        # Width = height, donc suffisant
        central_line = self.width() // self.grid_step / 2
        painter.setPen(pen)
        # Axe x
        painter.drawLine(
            0,
            central_line * self.grid_step,
            self.width(),
            central_line * self.grid_step,
        )
        # Axe y
        painter.drawLine(
            central_line * self.grid_step,
            0,
            central_line * self.grid_step,
            self.height(),
        )

    def drawAxisLabels(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine les labels des axes.

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        # Couleur noire
        pen = QPen(QColor(0, 0, 0))
        painter.setPen(pen)
        # QFont permet de définir les propriétés de la police
        font = QFont()
        font.setFamily(&#34;Arial&#34;)
        font.setPointSize(10)
        # applique les propriétés du QFont au pinceau
        painter.setFont(font)

        painter.drawText(self.width() - 40, self.height() / 2 + 30, &#34;Right&#34;)
        painter.drawText(self.width() / 2 - 85, 20, &#34;Autoritarian&#34;)
        painter.drawText(self.width() / 150, self.height() / 2 + 30, &#34;Left&#34;)
        painter.drawText(self.width() / 2 - 60, self.height() - 10, &#34;Liberal&#34;)

    def drawElectors(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine les points correspondants aux positions des électeurs (sans la démocratie liquide).

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        # Couleur bleue standard
        pen = QPen(QColor(0, 0, 255))
        pen.setWidth(4)
        painter.setPen(pen)
        for elector in self.election.electors:
            painter.drawPoint(self.scaleCoordinates(elector.position))

    def drawCandidates(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine les points correspondants aux positions des candidats.

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        # Couleur rouge standard
        pen = QPen(QColor(255, 0, 0))
        pen.setWidth(4)
        painter.setPen(pen)
        for candidate in self.election.candidates:
            fst_name, lst_name = candidate.first_name, candidate.last_name
            # Reconfiguration du pinceau après une itération de la boucle
            point_scaled = self.scaleCoordinates(candidate.position)
            painter.setPen(pen)
            painter.drawPoint(point_scaled)

            # Reconfiguration du style du pinceau pour le texte
            painter.setPen(QColor(0, 0, 0))
            point_mapped = self.transform.map(point_scaled)
            # Pour empêcher l&#39;inversion du texte
            painter.setWorldMatrixEnabled(False)
            point_text = self.getTextPosition(point_mapped)
            painter.drawText(point_mapped + point_text, f&#34;{fst_name} {lst_name}&#34;)
            painter.setWorldMatrixEnabled(True)

    def drawPoints(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine les points correspondants aux positions des électeurs (sans la démocratie liquide)
        et aux positions des candidats.

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        self.drawElectors(painter)
        self.drawCandidates(painter)

    def drawElectorsDelegation(self, painter: QPainter) -&gt; None:
        &#34;&#34;&#34;Dessine les points correspondants aux positions des électeurs (avec la démocratie liquide)
        i.e. avec les poids.

        Args:
            painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
        &#34;&#34;&#34;

        pen = QPen(QColor(128, 128, 128))
        pen.setWidth(4)
        painter.setPen(pen)
        for elector in self.election.electors:
            if elector.weight == 0:
                painter.drawPoint(self.scaleCoordinates(elector.position))

        for elector in self.election.electors:
            if elector.weight &gt; 0:
                pen3 = QPen(QColor(30, 144, 255))
                pen3.setWidth(4)
                painter.setPen(pen3)

                scaled_point = self.scaleCoordinates(elector.position)
                point_mapped = self.transform.map(scaled_point)

                painter.drawPoint(scaled_point)
                # Pour empêcher l&#39;inversion du texte
                painter.setWorldMatrixEnabled(False)
                point_text = self.getTextPosition(point_mapped)
                painter.drawText(point_mapped + point_text, f&#34;{elector.weight}&#34;)
                painter.setWorldMatrixEnabled(True)

        self.drawCandidates(painter)

    def scaleCoordinates(self, position: tuple[float, float]) -&gt; QPointF:
        &#34;&#34;&#34;Met les coordonnées normalisées à l&#39;échelle de la carte politique.

        Args:
            position (tuple[float, float]): Une position dont chaque coordonnée est normalisé.

        Returns:
            PySide6.QtCore.QPointF: Un point mis à l&#39;échelle.
        &#34;&#34;&#34;

        x, y = position
        return QPointF(x * self.width() / 2, y * self.height() / 2)

    def normalizeCoordinates(self, point: QPointF) -&gt; tuple[float, float]:
        &#34;&#34;&#34;Normalise chaque coordonnée du point.

        Args:
            point (PySide6.QtCore.QPointF): Un point mis à l&#39;échelle dans le système de coordonnées mathématique.

        Returns:
            position (tuple[float, float]): Une position dont chaque coordonnée est normalisé.
        &#34;&#34;&#34;

        return point.x() / self.width() * 2, point.y() / self.height() * 2

    def mousePressEvent(self, event: QMouseEvent) -&gt; None:
        &#34;&#34;&#34;Redéfinit `mousePressEvent` par défaut. Clique gauche: place un candidat manuellement en entrant son nom et prénom.
        Clique droite: place un électeur manuellement.&#34;&#34;&#34;

        inverted_transform, _ = self.transform.inverted()
        point_inv = inverted_transform.map(event.position())
        normalized_pos = self.normalizeCoordinates(point_inv)
        # Clique gauche
        if event.button() == Qt.LeftButton:
            self.election.add_elector(normalized_pos)
            self.update()

        # Clique droite
        if event.button() == Qt.RightButton and not self.text_box_active:
            # Création de la zone de texte
            self.createTextBox(event.position(), normalized_pos)
            self.text_box_active = True

    def createTextBox(self, point: QPointF, normalized_pos: tuple[float, float]) -&gt; None:
        &#34;&#34;&#34;Crée un textbox lors de la création manuelle d&#39;un candidat.

        Args:
            point (PySide6.QtCore.QPointF): Un point sur la carte politique (dans le système des coordonnées de l&#39;ordinateur).
            normalized_pos (tuple[float, float]): Une position du `point` mais normalisée et dans le système des coordonnées
                mathématique.
        &#34;&#34;&#34;

        # Création de la zone de texte
        self.text_box = QLineEdit(self)

        # Placement de la zone de texte à la position clique (avec décalage)
        self.text_box.move(self.getTextBoxPosition(point, self.text_box.size()))

        # Appelle de la fonction de création et de stockage du nom connecté avec la touche enter
        self.text_box.returnPressed.connect(lambda: self.storeName(normalized_pos))

        # Affiche la zone de texte la zone de texte
        self.text_box.show()

    def storeName(self, normalized_pos: tuple[float, float]) -&gt; None:
        &#34;&#34;&#34;Stocke le prénom et le nom d&#39;un candidat créé manuellement. Le nom et le prénom sont obligatoires.
        Crée un candidat, l&#39;ajoute dans l&#39;élection. Supprime le textbox. Redéssine la carte politique. 

        Args:
            normalized_pos (tuple[float, float]): Une position normalisée et dans le système des coordonnées mathématique.
        &#34;&#34;&#34;

        # Récupérer le texte
        full_name = self.text_box.text().strip().split(&#34; &#34;, 1)
        # Interdire la création de candidats avec uniquement le prénom
        if len(full_name) == 1:
            return
        first_name, last_name = tuple(full_name)

        self.election.add_candidate(normalized_pos, first_name, last_name)
        self.update()
        self.text_box_active = False
        # Supprime la zone de texte
        self.text_box.deleteLater()

    def getTextPosition(self, point: QPointF) -&gt; QPointF:
        &#34;&#34;&#34;Calcule les coordonnées du texte pour qu&#39;il ne sort pas en dehors de la carte politique.

        Args:
            point (PySide6.QtCore.QPointF): Un point dans le système des coordonnés de l&#39;ordinateur. Correpond au point d&#39;origine.

        Returns:
            PySide6.QtCore.QPointF: Un point qui correpond aux coordonnées du texte où il faudra le dessiner (i.e. c&#39;est un point
                déjà décalé à partir du `point`). C&#39;est le point dans le système des coordonnés de l&#39;ordinateur.
        &#34;&#34;&#34;

        point_text = QPoint(5, 15)
        shift = point + point_text

        # Over the map on X &amp; Y
        if shift.x() + 100 &gt; self.width() and shift.y() + 100 &gt; self.height():
            # Inverse, flip X &amp; Y
            point_text = QPointF(-point_text.y(), -point_text.x())
        # Over the map on X
        elif shift.x() + 100 &gt; self.width():
            point_text = QPointF(-point_text.x(), point_text.y())
        # Over the map on Y
        elif shift.y() + 100 &gt; self.height():
            point_text = QPointF(point_text.x(), -point_text.y())

        return point_text

    def getTextBoxPosition(self, point: QPointF, size: QSize) -&gt; QPoint:
        &#34;&#34;&#34;Calcule les coordonnées du textbox pour qu&#39;il ne sort pas en dehors de la carte politique.

        Args:
            point (PySide6.QtCore.QPointF): Un point dans le système des coordonnés de l&#39;ordinateur. Correpond au point d&#39;origine.
            size (PySide6.QtCore.QSize): La taille du textbox.

        Returns:
            PySide6.QtCore.QPoint: Un point qui correpond aux coordonnées du texte où il faudra le dessiner (i.e. c&#39;est un point
                déjà décalé à partir du `point`). C&#39;est le point dans le système des coordonnés de l&#39;ordinateur.
        &#34;&#34;&#34;

        width, height = size.width(), size.height()
        point_textbox = point.toPoint()
        if point.x() + width &gt; self.width():
            point_textbox = QPoint(point_textbox.x() - width, point_textbox.y())
        if point.y() + height &gt; self.height():
            point_textbox = QPoint(point_textbox.x(), point_textbox.y() - height)

        return point_textbox

    def generateCoordinate(self, mu: float, sigma: float, limit: float) -&gt; float:
        &#34;&#34;&#34;Génére une coordonnée (x ou y) selon la loi normale avec des paramètres `mu` et `sigma`.
        Borne la valeur absolue d&#39;une coordonnée généré entre `limit`.

        Args:
            mu (float): La moyenne de la distribution normale. 
            sigma (float): L&#39;écart type de la distribution normale. Un réel strictement positive.
            lower_limit (float): La limite inférieure et supérieur pour le coordonnée. 

        Returns:
            float: Un coordonnée généré et borné.
        &#34;&#34;&#34;

        coordinate = normal(mu, sigma)

        # Nombre max de regénération d&#39;un coordonnée. Sinon, la boucle très longue possible
        max_iterations = 5
        while abs(coordinate) &gt; limit and max_iterations:
            coordinate = normal(mu, sigma)
            max_iterations -= 1

        # Si la valeur regénérée est encore hors bornes
        coordinate = clip(coordinate, -1, 1)

        return coordinate

    def generatePosition(self) -&gt; tuple[float, float]:
        &#34;&#34;&#34;Génére une position sur la carte politique selon la loi normale.

        Returns:
            tuple[float, float]: Une position générée dont chaque coordonnée est normalisé et borné.  
        &#34;&#34;&#34;

        constants = self.election.generation_constants
        economical_constants = constants[RandomConstants.ECONOMICAL]
        social_constants = constants[RandomConstants.SOCIAL]
        coef_dir = constants[RandomConstants.ORIENTATION]

        mu, sigma = economical_constants[0], economical_constants[1]
        x = self.generateCoordinate(mu, sigma, limit=1)

        mu, sigma = coef_dir * x + social_constants[0], social_constants[1]
        y = self.generateCoordinate(mu, sigma, limit=1)
        return (x, y)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PySide6.QtWidgets.QWidget</li>
<li>PySide6.QtCore.QObject</li>
<li>PySide6.QtGui.QPaintDevice</li>
<li>Shiboken.Object</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.staticMetaObject"><code class="name">var <span class="ident">staticMetaObject</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.createTextBox"><code class="name flex">
<span>def <span class="ident">createTextBox</span></span>(<span>self, point: PySide6.QtCore.QPointF, normalized_pos: tuple[float, float]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Crée un textbox lors de la création manuelle d'un candidat.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>PySide6.QtCore.QPointF</code></dt>
<dd>Un point sur la carte politique (dans le système des coordonnées de l'ordinateur).</dd>
<dt><strong><code>normalized_pos</code></strong> :&ensp;<code>tuple[float, float]</code></dt>
<dd>Une position du <code>point</code> mais normalisée et dans le système des coordonnées
mathématique.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createTextBox(self, point: QPointF, normalized_pos: tuple[float, float]) -&gt; None:
    &#34;&#34;&#34;Crée un textbox lors de la création manuelle d&#39;un candidat.

    Args:
        point (PySide6.QtCore.QPointF): Un point sur la carte politique (dans le système des coordonnées de l&#39;ordinateur).
        normalized_pos (tuple[float, float]): Une position du `point` mais normalisée et dans le système des coordonnées
            mathématique.
    &#34;&#34;&#34;

    # Création de la zone de texte
    self.text_box = QLineEdit(self)

    # Placement de la zone de texte à la position clique (avec décalage)
    self.text_box.move(self.getTextBoxPosition(point, self.text_box.size()))

    # Appelle de la fonction de création et de stockage du nom connecté avec la touche enter
    self.text_box.returnPressed.connect(lambda: self.storeName(normalized_pos))

    # Affiche la zone de texte la zone de texte
    self.text_box.show()</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawAxes"><code class="name flex">
<span>def <span class="ident">drawAxes</span></span>(<span>self, painter: PySide6.QtGui.QPainter) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Dessine les axes X, Y.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>PySide6.QtGui.QPainter</code></dt>
<dd>Un painter déjà initiliasé.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawAxes(self, painter: QPainter) -&gt; None:
    &#34;&#34;&#34;Dessine les axes X, Y.

    Args:
        painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
    &#34;&#34;&#34;

    # Couleur noire
    pen = QPen(QColor(0, 0, 0))
    pen.setWidth(2)

    # Width = height, donc suffisant
    central_line = self.width() // self.grid_step / 2
    painter.setPen(pen)
    # Axe x
    painter.drawLine(
        0,
        central_line * self.grid_step,
        self.width(),
        central_line * self.grid_step,
    )
    # Axe y
    painter.drawLine(
        central_line * self.grid_step,
        0,
        central_line * self.grid_step,
        self.height(),
    )</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawAxisLabels"><code class="name flex">
<span>def <span class="ident">drawAxisLabels</span></span>(<span>self, painter: PySide6.QtGui.QPainter) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Dessine les labels des axes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>PySide6.QtGui.QPainter</code></dt>
<dd>Un painter déjà initiliasé.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawAxisLabels(self, painter: QPainter) -&gt; None:
    &#34;&#34;&#34;Dessine les labels des axes.

    Args:
        painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
    &#34;&#34;&#34;

    # Couleur noire
    pen = QPen(QColor(0, 0, 0))
    painter.setPen(pen)
    # QFont permet de définir les propriétés de la police
    font = QFont()
    font.setFamily(&#34;Arial&#34;)
    font.setPointSize(10)
    # applique les propriétés du QFont au pinceau
    painter.setFont(font)

    painter.drawText(self.width() - 40, self.height() / 2 + 30, &#34;Right&#34;)
    painter.drawText(self.width() / 2 - 85, 20, &#34;Autoritarian&#34;)
    painter.drawText(self.width() / 150, self.height() / 2 + 30, &#34;Left&#34;)
    painter.drawText(self.width() / 2 - 60, self.height() - 10, &#34;Liberal&#34;)</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawCandidates"><code class="name flex">
<span>def <span class="ident">drawCandidates</span></span>(<span>self, painter: PySide6.QtGui.QPainter) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Dessine les points correspondants aux positions des candidats.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>PySide6.QtGui.QPainter</code></dt>
<dd>Un painter déjà initiliasé.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawCandidates(self, painter: QPainter) -&gt; None:
    &#34;&#34;&#34;Dessine les points correspondants aux positions des candidats.

    Args:
        painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
    &#34;&#34;&#34;

    # Couleur rouge standard
    pen = QPen(QColor(255, 0, 0))
    pen.setWidth(4)
    painter.setPen(pen)
    for candidate in self.election.candidates:
        fst_name, lst_name = candidate.first_name, candidate.last_name
        # Reconfiguration du pinceau après une itération de la boucle
        point_scaled = self.scaleCoordinates(candidate.position)
        painter.setPen(pen)
        painter.drawPoint(point_scaled)

        # Reconfiguration du style du pinceau pour le texte
        painter.setPen(QColor(0, 0, 0))
        point_mapped = self.transform.map(point_scaled)
        # Pour empêcher l&#39;inversion du texte
        painter.setWorldMatrixEnabled(False)
        point_text = self.getTextPosition(point_mapped)
        painter.drawText(point_mapped + point_text, f&#34;{fst_name} {lst_name}&#34;)
        painter.setWorldMatrixEnabled(True)</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawElectors"><code class="name flex">
<span>def <span class="ident">drawElectors</span></span>(<span>self, painter: PySide6.QtGui.QPainter) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Dessine les points correspondants aux positions des électeurs (sans la démocratie liquide).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>PySide6.QtGui.QPainter</code></dt>
<dd>Un painter déjà initiliasé.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawElectors(self, painter: QPainter) -&gt; None:
    &#34;&#34;&#34;Dessine les points correspondants aux positions des électeurs (sans la démocratie liquide).

    Args:
        painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
    &#34;&#34;&#34;

    # Couleur bleue standard
    pen = QPen(QColor(0, 0, 255))
    pen.setWidth(4)
    painter.setPen(pen)
    for elector in self.election.electors:
        painter.drawPoint(self.scaleCoordinates(elector.position))</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawElectorsDelegation"><code class="name flex">
<span>def <span class="ident">drawElectorsDelegation</span></span>(<span>self, painter: PySide6.QtGui.QPainter) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Dessine les points correspondants aux positions des électeurs (avec la démocratie liquide)
i.e. avec les poids.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>PySide6.QtGui.QPainter</code></dt>
<dd>Un painter déjà initiliasé.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawElectorsDelegation(self, painter: QPainter) -&gt; None:
    &#34;&#34;&#34;Dessine les points correspondants aux positions des électeurs (avec la démocratie liquide)
    i.e. avec les poids.

    Args:
        painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
    &#34;&#34;&#34;

    pen = QPen(QColor(128, 128, 128))
    pen.setWidth(4)
    painter.setPen(pen)
    for elector in self.election.electors:
        if elector.weight == 0:
            painter.drawPoint(self.scaleCoordinates(elector.position))

    for elector in self.election.electors:
        if elector.weight &gt; 0:
            pen3 = QPen(QColor(30, 144, 255))
            pen3.setWidth(4)
            painter.setPen(pen3)

            scaled_point = self.scaleCoordinates(elector.position)
            point_mapped = self.transform.map(scaled_point)

            painter.drawPoint(scaled_point)
            # Pour empêcher l&#39;inversion du texte
            painter.setWorldMatrixEnabled(False)
            point_text = self.getTextPosition(point_mapped)
            painter.drawText(point_mapped + point_text, f&#34;{elector.weight}&#34;)
            painter.setWorldMatrixEnabled(True)

    self.drawCandidates(painter)</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawGrid"><code class="name flex">
<span>def <span class="ident">drawGrid</span></span>(<span>self, painter: PySide6.QtGui.QPainter) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Dessine la grille.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>PySide6.QtGui.QPainter</code></dt>
<dd>Un painter déjà initiliasé.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawGrid(self, painter: QPainter) -&gt; None:
    &#34;&#34;&#34;Dessine la grille.

    Args:
        painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
    &#34;&#34;&#34;

    # Couleur gris clair
    pen = QPen(QColor(220, 220, 220))
    painter.setPen(pen)
    # nb_lines = nb_rows = nb_cols
    nb_lines = self.width() // self.grid_step

    for row in range(1, nb_lines + 1):
        # lignes verticales
        painter.drawLine(
            row * self.grid_step, 0, row * self.grid_step, self.height()
        )
        # lignes horizontales
        painter.drawLine(
            0, row * self.grid_step, self.width(), row * self.grid_step
        )</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawPoints"><code class="name flex">
<span>def <span class="ident">drawPoints</span></span>(<span>self, painter: PySide6.QtGui.QPainter) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Dessine les points correspondants aux positions des électeurs (sans la démocratie liquide)
et aux positions des candidats.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>PySide6.QtGui.QPainter</code></dt>
<dd>Un painter déjà initiliasé.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawPoints(self, painter: QPainter) -&gt; None:
    &#34;&#34;&#34;Dessine les points correspondants aux positions des électeurs (sans la démocratie liquide)
    et aux positions des candidats.

    Args:
        painter (PySide6.QtGui.QPainter): Un painter déjà initiliasé.
    &#34;&#34;&#34;

    self.drawElectors(painter)
    self.drawCandidates(painter)</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.generateCoordinate"><code class="name flex">
<span>def <span class="ident">generateCoordinate</span></span>(<span>self, mu: float, sigma: float, limit: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Génére une coordonnée (x ou y) selon la loi normale avec des paramètres <code>mu</code> et <code>sigma</code>.
Borne la valeur absolue d'une coordonnée généré entre <code>limit</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mu</code></strong> :&ensp;<code>float</code></dt>
<dd>La moyenne de la distribution normale. </dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code>float</code></dt>
<dd>L'écart type de la distribution normale. Un réel strictement positive.</dd>
<dt><strong><code>lower_limit</code></strong> :&ensp;<code>float</code></dt>
<dd>La limite inférieure et supérieur pour le coordonnée. </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Un coordonnée généré et borné.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateCoordinate(self, mu: float, sigma: float, limit: float) -&gt; float:
    &#34;&#34;&#34;Génére une coordonnée (x ou y) selon la loi normale avec des paramètres `mu` et `sigma`.
    Borne la valeur absolue d&#39;une coordonnée généré entre `limit`.

    Args:
        mu (float): La moyenne de la distribution normale. 
        sigma (float): L&#39;écart type de la distribution normale. Un réel strictement positive.
        lower_limit (float): La limite inférieure et supérieur pour le coordonnée. 

    Returns:
        float: Un coordonnée généré et borné.
    &#34;&#34;&#34;

    coordinate = normal(mu, sigma)

    # Nombre max de regénération d&#39;un coordonnée. Sinon, la boucle très longue possible
    max_iterations = 5
    while abs(coordinate) &gt; limit and max_iterations:
        coordinate = normal(mu, sigma)
        max_iterations -= 1

    # Si la valeur regénérée est encore hors bornes
    coordinate = clip(coordinate, -1, 1)

    return coordinate</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.generatePosition"><code class="name flex">
<span>def <span class="ident">generatePosition</span></span>(<span>self) ‑> tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Génére une position sur la carte politique selon la loi normale.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[float, float]</code></dt>
<dd>Une position générée dont chaque coordonnée est normalisé et borné.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generatePosition(self) -&gt; tuple[float, float]:
    &#34;&#34;&#34;Génére une position sur la carte politique selon la loi normale.

    Returns:
        tuple[float, float]: Une position générée dont chaque coordonnée est normalisé et borné.  
    &#34;&#34;&#34;

    constants = self.election.generation_constants
    economical_constants = constants[RandomConstants.ECONOMICAL]
    social_constants = constants[RandomConstants.SOCIAL]
    coef_dir = constants[RandomConstants.ORIENTATION]

    mu, sigma = economical_constants[0], economical_constants[1]
    x = self.generateCoordinate(mu, sigma, limit=1)

    mu, sigma = coef_dir * x + social_constants[0], social_constants[1]
    y = self.generateCoordinate(mu, sigma, limit=1)
    return (x, y)</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.getTextBoxPosition"><code class="name flex">
<span>def <span class="ident">getTextBoxPosition</span></span>(<span>self, point: PySide6.QtCore.QPointF, size: PySide6.QtCore.QSize) ‑> PySide6.QtCore.QPoint</span>
</code></dt>
<dd>
<div class="desc"><p>Calcule les coordonnées du textbox pour qu'il ne sort pas en dehors de la carte politique.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>PySide6.QtCore.QPointF</code></dt>
<dd>Un point dans le système des coordonnés de l'ordinateur. Correpond au point d'origine.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>PySide6.QtCore.QSize</code></dt>
<dd>La taille du textbox.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PySide6.QtCore.QPoint</code></dt>
<dd>Un point qui correpond aux coordonnées du texte où il faudra le dessiner (i.e. c'est un point
déjà décalé à partir du <code>point</code>). C'est le point dans le système des coordonnés de l'ordinateur.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTextBoxPosition(self, point: QPointF, size: QSize) -&gt; QPoint:
    &#34;&#34;&#34;Calcule les coordonnées du textbox pour qu&#39;il ne sort pas en dehors de la carte politique.

    Args:
        point (PySide6.QtCore.QPointF): Un point dans le système des coordonnés de l&#39;ordinateur. Correpond au point d&#39;origine.
        size (PySide6.QtCore.QSize): La taille du textbox.

    Returns:
        PySide6.QtCore.QPoint: Un point qui correpond aux coordonnées du texte où il faudra le dessiner (i.e. c&#39;est un point
            déjà décalé à partir du `point`). C&#39;est le point dans le système des coordonnés de l&#39;ordinateur.
    &#34;&#34;&#34;

    width, height = size.width(), size.height()
    point_textbox = point.toPoint()
    if point.x() + width &gt; self.width():
        point_textbox = QPoint(point_textbox.x() - width, point_textbox.y())
    if point.y() + height &gt; self.height():
        point_textbox = QPoint(point_textbox.x(), point_textbox.y() - height)

    return point_textbox</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.getTextPosition"><code class="name flex">
<span>def <span class="ident">getTextPosition</span></span>(<span>self, point: PySide6.QtCore.QPointF) ‑> PySide6.QtCore.QPointF</span>
</code></dt>
<dd>
<div class="desc"><p>Calcule les coordonnées du texte pour qu'il ne sort pas en dehors de la carte politique.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>PySide6.QtCore.QPointF</code></dt>
<dd>Un point dans le système des coordonnés de l'ordinateur. Correpond au point d'origine.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PySide6.QtCore.QPointF</code></dt>
<dd>Un point qui correpond aux coordonnées du texte où il faudra le dessiner (i.e. c'est un point
déjà décalé à partir du <code>point</code>). C'est le point dans le système des coordonnés de l'ordinateur.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTextPosition(self, point: QPointF) -&gt; QPointF:
    &#34;&#34;&#34;Calcule les coordonnées du texte pour qu&#39;il ne sort pas en dehors de la carte politique.

    Args:
        point (PySide6.QtCore.QPointF): Un point dans le système des coordonnés de l&#39;ordinateur. Correpond au point d&#39;origine.

    Returns:
        PySide6.QtCore.QPointF: Un point qui correpond aux coordonnées du texte où il faudra le dessiner (i.e. c&#39;est un point
            déjà décalé à partir du `point`). C&#39;est le point dans le système des coordonnés de l&#39;ordinateur.
    &#34;&#34;&#34;

    point_text = QPoint(5, 15)
    shift = point + point_text

    # Over the map on X &amp; Y
    if shift.x() + 100 &gt; self.width() and shift.y() + 100 &gt; self.height():
        # Inverse, flip X &amp; Y
        point_text = QPointF(-point_text.y(), -point_text.x())
    # Over the map on X
    elif shift.x() + 100 &gt; self.width():
        point_text = QPointF(-point_text.x(), point_text.y())
    # Over the map on Y
    elif shift.y() + 100 &gt; self.height():
        point_text = QPointF(point_text.x(), -point_text.y())

    return point_text</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.initUI"><code class="name flex">
<span>def <span class="ident">initUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialise le layout. Changee la couleur d'arrière-plan sur blanc. Initialise le step pour dessiner la grille.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initUI(self):
    &#34;&#34;&#34;Initialise le layout. Changee la couleur d&#39;arrière-plan sur blanc. Initialise le step pour dessiner la grille.&#34;&#34;&#34;

    self.layout = QVBoxLayout(self)
    self.setPallete()

    self.grid_step = 20
    self.text_box_active = False</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.mousePressEvent"><code class="name flex">
<span>def <span class="ident">mousePressEvent</span></span>(<span>self, event: PySide6.QtGui.QMouseEvent) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Redéfinit <code>mousePressEvent</code> par défaut. Clique gauche: place un candidat manuellement en entrant son nom et prénom.
Clique droite: place un électeur manuellement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mousePressEvent(self, event: QMouseEvent) -&gt; None:
    &#34;&#34;&#34;Redéfinit `mousePressEvent` par défaut. Clique gauche: place un candidat manuellement en entrant son nom et prénom.
    Clique droite: place un électeur manuellement.&#34;&#34;&#34;

    inverted_transform, _ = self.transform.inverted()
    point_inv = inverted_transform.map(event.position())
    normalized_pos = self.normalizeCoordinates(point_inv)
    # Clique gauche
    if event.button() == Qt.LeftButton:
        self.election.add_elector(normalized_pos)
        self.update()

    # Clique droite
    if event.button() == Qt.RightButton and not self.text_box_active:
        # Création de la zone de texte
        self.createTextBox(event.position(), normalized_pos)
        self.text_box_active = True</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.normalizeCoordinates"><code class="name flex">
<span>def <span class="ident">normalizeCoordinates</span></span>(<span>self, point: PySide6.QtCore.QPointF) ‑> tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Normalise chaque coordonnée du point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>PySide6.QtCore.QPointF</code></dt>
<dd>Un point mis à l'échelle dans le système de coordonnées mathématique.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>position (tuple[float, float]): Une position dont chaque coordonnée est normalisé.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalizeCoordinates(self, point: QPointF) -&gt; tuple[float, float]:
    &#34;&#34;&#34;Normalise chaque coordonnée du point.

    Args:
        point (PySide6.QtCore.QPointF): Un point mis à l&#39;échelle dans le système de coordonnées mathématique.

    Returns:
        position (tuple[float, float]): Une position dont chaque coordonnée est normalisé.
    &#34;&#34;&#34;

    return point.x() / self.width() * 2, point.y() / self.height() * 2</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.paintEvent"><code class="name flex">
<span>def <span class="ident">paintEvent</span></span>(<span>self, event: PySide6.QtGui.QPaintEvent) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Redéfinit <code>paintEvent</code> par défaut. Dessine la grille, les axes X, Y. Applique la transformation.
Dessine les points correspondant aux positions des candidats et des électeurs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paintEvent(self, event: QPaintEvent) -&gt; None:
    &#34;&#34;&#34;Redéfinit `paintEvent` par défaut. Dessine la grille, les axes X, Y. Applique la transformation.
    Dessine les points correspondant aux positions des candidats et des électeurs.&#34;&#34;&#34;

    painter = QPainter(self)
    self.drawGrid(painter)
    self.drawAxes(painter)
    self.drawAxisLabels(painter)

    painter.setTransform(self.transform)

    if self.draw_delegations:
        self.drawElectorsDelegation(painter)
    else:
        self.drawPoints(painter)</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.scaleCoordinates"><code class="name flex">
<span>def <span class="ident">scaleCoordinates</span></span>(<span>self, position: tuple[float, float]) ‑> PySide6.QtCore.QPointF</span>
</code></dt>
<dd>
<div class="desc"><p>Met les coordonnées normalisées à l'échelle de la carte politique.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>tuple[float, float]</code></dt>
<dd>Une position dont chaque coordonnée est normalisé.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PySide6.QtCore.QPointF</code></dt>
<dd>Un point mis à l'échelle.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaleCoordinates(self, position: tuple[float, float]) -&gt; QPointF:
    &#34;&#34;&#34;Met les coordonnées normalisées à l&#39;échelle de la carte politique.

    Args:
        position (tuple[float, float]): Une position dont chaque coordonnée est normalisé.

    Returns:
        PySide6.QtCore.QPointF: Un point mis à l&#39;échelle.
    &#34;&#34;&#34;

    x, y = position
    return QPointF(x * self.width() / 2, y * self.height() / 2)</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.setPallete"><code class="name flex">
<span>def <span class="ident">setPallete</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Change la couleur d'arrière-plan sur blanc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setPallete(self) -&gt; None:
    &#34;&#34;&#34;Change la couleur d&#39;arrière-plan sur blanc.&#34;&#34;&#34;

    self.setAutoFillBackground(True)
    pallete = self.palette()
    pallete.setColor(self.backgroundRole(), QColor(255, 255, 255))
    self.setPalette(pallete)</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.setTransformation"><code class="name flex">
<span>def <span class="ident">setTransformation</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialise (mais n'applique pas) la transformation des coordonnées de l'ordinateur.
But: avoir un système des coordonnées comme en maths.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTransformation(self) -&gt; None:
    &#34;&#34;&#34;Initialise (mais n&#39;applique pas) la transformation des coordonnées de l&#39;ordinateur.
    But: avoir un système des coordonnées comme en maths.&#34;&#34;&#34;

    self.transform = QTransform()
    # L&#39;ordre a l&#39;importance!
    # Flip Y-axis
    self.transform.scale(1, -1)
    # Move center
    self.transform.translate(self.width() / 2, -self.height() / 2)</code></pre>
</details>
</dd>
<dt id="graphics.widget_map_utls.quadrant_map.QuadrantMap.storeName"><code class="name flex">
<span>def <span class="ident">storeName</span></span>(<span>self, normalized_pos: tuple[float, float]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Stocke le prénom et le nom d'un candidat créé manuellement. Le nom et le prénom sont obligatoires.
Crée un candidat, l'ajoute dans l'élection. Supprime le textbox. Redéssine la carte politique. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>normalized_pos</code></strong> :&ensp;<code>tuple[float, float]</code></dt>
<dd>Une position normalisée et dans le système des coordonnées mathématique.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def storeName(self, normalized_pos: tuple[float, float]) -&gt; None:
    &#34;&#34;&#34;Stocke le prénom et le nom d&#39;un candidat créé manuellement. Le nom et le prénom sont obligatoires.
    Crée un candidat, l&#39;ajoute dans l&#39;élection. Supprime le textbox. Redéssine la carte politique. 

    Args:
        normalized_pos (tuple[float, float]): Une position normalisée et dans le système des coordonnées mathématique.
    &#34;&#34;&#34;

    # Récupérer le texte
    full_name = self.text_box.text().strip().split(&#34; &#34;, 1)
    # Interdire la création de candidats avec uniquement le prénom
    if len(full_name) == 1:
        return
    first_name, last_name = tuple(full_name)

    self.election.add_candidate(normalized_pos, first_name, last_name)
    self.update()
    self.text_box_active = False
    # Supprime la zone de texte
    self.text_box.deleteLater()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="graphics.widget_map_utls" href="index.html">graphics.widget_map_utls</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="graphics.widget_map_utls.quadrant_map.normal" href="#graphics.widget_map_utls.quadrant_map.normal">normal</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap">QuadrantMap</a></code></h4>
<ul class="">
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.createTextBox" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.createTextBox">createTextBox</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawAxes" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.drawAxes">drawAxes</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawAxisLabels" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.drawAxisLabels">drawAxisLabels</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawCandidates" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.drawCandidates">drawCandidates</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawElectors" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.drawElectors">drawElectors</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawElectorsDelegation" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.drawElectorsDelegation">drawElectorsDelegation</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawGrid" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.drawGrid">drawGrid</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.drawPoints" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.drawPoints">drawPoints</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.generateCoordinate" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.generateCoordinate">generateCoordinate</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.generatePosition" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.generatePosition">generatePosition</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.getTextBoxPosition" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.getTextBoxPosition">getTextBoxPosition</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.getTextPosition" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.getTextPosition">getTextPosition</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.initUI" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.initUI">initUI</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.mousePressEvent" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.mousePressEvent">mousePressEvent</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.normalizeCoordinates" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.normalizeCoordinates">normalizeCoordinates</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.paintEvent" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.paintEvent">paintEvent</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.scaleCoordinates" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.scaleCoordinates">scaleCoordinates</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.setPallete" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.setPallete">setPallete</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.setTransformation" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.setTransformation">setTransformation</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.staticMetaObject" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.staticMetaObject">staticMetaObject</a></code></li>
<li><code><a title="graphics.widget_map_utls.quadrant_map.QuadrantMap.storeName" href="#graphics.widget_map_utls.quadrant_map.QuadrantMap.storeName">storeName</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>