<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>electoral_systems.election API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>electoral_systems.election</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Set, Optional, List, Union, Dict
from math import sqrt
from random import random

from .utls import Singleton, NameIterator, IdIterator
from .election_constants import RandomConstants, VotingRulesConstants
from .extensions.polls import (
    add_elector_data,
    add_candidate_data,
    get_default_directions_data,
    set_avg_electors_positions,
    set_std_deviation,
    change_position_candidates,
    change_ranking_electors,
)
from .extensions.liquid_democracy import choose_delegee, choose_possible_delegees
from .voting_rules.utls import set_duels_scores, sort_cand_by_value, sort_cand_by_round, duels_type

from people import Candidate, Elector

# Pour une génération des docs uniquement 
__pdoc__ = {
    &#39;random&#39;:False,
    &#39;Election._init_results_keys&#39;:True,
    &#39;Election._calc_distance&#39;:True,
    &#39;Election._define_ranking&#39;:True,
    &#39;Election._calc_proportion_satisfaction&#39;:True,
    &#39;Election._make_delegations&#39;:True
}

class Election(metaclass=Singleton):
    &#34;&#34;&#34;Une classe Singleton qui contient toutes les données nécessaires à une élection.&#34;&#34;&#34;

    def __init__(self):
        super().__init__()
        self.electors:List[Elector] = []
        &#34;&#34;&#34;Une liste qui stocke tous les électeurs qui participent dans une élection.&#34;&#34;&#34;

        self.candidates = []
        &#34;&#34;&#34;Une liste qui stocke tous les candidats qui participent dans une élection.&#34;&#34;&#34;

        self.first_name_iter = NameIterator()
        &#34;&#34;&#34;Un itérateur qui génére des prénoms des candidats (uniquement pour les données générées aléatoirement)&#34;&#34;&#34;

        self.last_name_iter = NameIterator()
        &#34;&#34;&#34;Un itérateur qui génére des noms des candidats (uniquement pour les données générées aléatoirement)&#34;&#34;&#34;

        self.id_iter = IdIterator(0)
        &#34;&#34;&#34;Un itérateur qui génére des IDs des candidats et des électeurs.&#34;&#34;&#34;

        # Stocke les resultats
        self.results:Dict[str, List[Candidate]] = dict()
        &#34;&#34;&#34;Un dictionnaire qui stocke un classement des candidats (dans l&#39;ordre décroissant) pour chaque règle de vote choisie.&#34;&#34;&#34;

        # Stocke les duels
        self.duels_scores:duels_type = dict()
        &#34;&#34;&#34;Un dictionnaire qui stocke les résultats des duels entre les candidats.&#34;&#34;&#34;

        # Pour la satisfaction
        self.average_position_electors:tuple[float, float] = (0, 0)
        self.proportion_satisfaction:float = 0
        &#34;&#34;&#34;La distance maximale entre la position moyenne des électeurs et la position de chaque candidat.&#34;&#34;&#34;

        # Init les constantes
        self.set_default_settings()

    def set_default_settings(self) -&gt; None:
        &#34;&#34;&#34;Initialise les réglages par défaut.&#34;&#34;&#34;

        # Nb de sondages à faire
        self.nb_polls:int = 0
        &#34;&#34;&#34;Un nombre des sondages à faire&#34;&#34;&#34;

        # Active/désactive la démocratie liquide
        self.liquid_democracy_activated = False

        # Une règle de vote pour les sondages
        self.poll_voting_rule = VotingRulesConstants.PLURALITY_SIMPLE

        # Active/désactive un tie-break selon les duels
        self.tie_breaker_activated = True

        # Les constantes de la génération des données
        self.generation_constants = dict()
        for type, default_value in RandomConstants.DEFAULT_VALUES.items():
            self.generation_constants[type] = default_value

        # Pour les sondages uniquement. Stocke les données pour chaque direction (division) de la carte politique
        self.directions_data = get_default_directions_data()

    def _init_results_keys(self, set_keys: Set[str]) -&gt; None:
        &#34;&#34;&#34;Initialiser des clés du dictionnaire `results` avec des constantes associées aux règles du vote choisies.
        Les valeurs sont rémies à `None`.
        &#34;&#34;&#34;

        for key in set_keys:
            self.results[key] = None

    def _calc_distance(self, point1: tuple[float, float], point2: tuple[float, float]) -&gt; float:
        &#34;&#34;&#34;Calcule la distance euclidienne entre 2 points.

        Args:
            point1 (tuple[float, float]): position sur la carte politique
            point2 (tuple[float, float]): position sur la carte politique
        Returns:
            float: La distance euclidienne entre 2 points.
        &#34;&#34;&#34;
        x1, y1 = point1
        x2, y2 = point2
        return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)

    def has_electors_candidates(self) -&gt; bool:
        &#34;&#34;&#34;Vérifie qu&#39;il existe au moins un électeur et un candidat dans une élection.

        Returns:
            bool: `True` s&#39;il existe au moins un électeur et un candidat dans une élection, sinon `False`.
        &#34;&#34;&#34;

        if not self.electors and not self.candidates:
            return False
        return True

    def add_elector_import(self, new_elector: Elector) -&gt; None:
        &#34;&#34;&#34;Ajoute un électeur dont les données sont déjà initialisées. 
        Si les sondages sont activés, MAJ les données sur les directions de la carte politique. 
        MAJ les données sur la position moyenne de tous les électeurs participants à l&#39;élection. 
        Utilisée lors d&#39;une importation des données.

        Args:
            new_elector (people.elector.Elector): Un nouvel électeur.
        &#34;&#34;&#34;

        if self.nb_polls:
            add_elector_data(self.directions_data, new_elector)

        x, y = new_elector.position
        x_avg, y_avg = self.average_position_electors
        x_avg, y_avg = x_avg + x, y_avg + y
        self.average_position_electors = (x_avg, y_avg)

        self.electors.append(new_elector)

    def add_elector(self, position: tuple[float, float]) -&gt; None:
        &#34;&#34;&#34;Ajoute un nouvel électeur dans une élection avec sa position position. 
        Si les sondages sont activés, MAJ les données sur les directions de la carte politique. 
        MAJ les données sur la position moyenne de tous les électeurs participants à l&#39;élection.

        Args:
            position (tuple[float, float]): La position d&#39;un électeur sur la carte politique. 
                Chaque coordonnée doit être bornée entre -1 et 1.
        &#34;&#34;&#34;

        knowledge_const = self.generation_constants[RandomConstants.KNOWLEDGE]
        new_elector = Elector(
            id=next(self.id_iter), position=position, knowledge_const=knowledge_const
        )
        x, y = new_elector.position

        if self.nb_polls:
            add_elector_data(self.directions_data, new_elector)

        # All electors average
        x_avg, y_avg = self.average_position_electors
        x_avg, y_avg = x_avg + x, y_avg + y
        self.average_position_electors = (x_avg, y_avg)
        self.electors.append(new_elector)

    def add_candidate_import(self, new_candidate: Candidate) -&gt; None:
        &#34;&#34;&#34;Ajoute un candidat dont les données sont déjà initialisées. 
        Si les sondages sont activés, MAJ les données sur les directions de la carte politique. 
        Utilisée lors d&#39;une importation des données.

        Args:
            new_elector (people.elector.Elector): Un nouvel électeur.
        &#34;&#34;&#34;

        self.candidates.append(new_candidate)
        if self.nb_polls:
            add_candidate_data(self.directions_data, new_candidate)

    def add_candidate(self, position: tuple[float, float], first_name: Optional[str] = &#34;&#34;, last_name: Optional[str] = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;Ajoute un nouveau candidat dans une élection avec sa position position, 
        et éventuellement son nom (`last_name`) et son prénom (`first_name`). Si les sondages sont activés, 
        MAJ les données sur les directions de la carte politique.

        Args:
            position (tuple[float, float]): La position d&#39;un candidat sur la carte politique. 
                Chaque coordonnée doit être bornée entre -1 et 1.
            first_name (Optional[str]): Le prénom d&#39;un candidat.
            last_name (Optional[str]): Le nom d&#39;un candidat.
        &#34;&#34;&#34;

        dogmat_const = self.generation_constants[RandomConstants.DOGMATISM]
        oppos_const = self.generation_constants[RandomConstants.OPPOSITION]

        first_name = next(self.first_name_iter) if not first_name else first_name
        last_name = next(self.last_name_iter) if not last_name else last_name

        new_candidate = Candidate(
            id=next(self.id_iter),
            position=position,
            first_name=first_name,
            last_name=last_name,
            dogmatism_const=dogmat_const,
            opposition_const=oppos_const,
        )
        if self.nb_polls:
            add_candidate_data(self.directions_data, new_candidate)

        self.candidates.append(new_candidate)

    def apply_voting_rule(self, voting_rule: str) -&gt; None:
        &#34;&#34;&#34;Applique une règle de vote voting_rule. 
        Remplit la case correspondante à voting_rule du dictionnaire results avec une liste (un classement) des candidats. 
        La fonction est appliquée uniquement s&#39;il existe au moins un électeur et un candidat, sinon elle ne fait rien.

        Args:
            voting_rule (str): Une constante correspondant à une règle de vote.
        &#34;&#34;&#34;

        if not self.has_electors_candidates():
            return

        result = []
        func = VotingRulesConstants.VOTING_RULES_FUNC[voting_rule]

        if voting_rule in VotingRulesConstants.CONDORCET:
            result = func(self.electors, self.candidates, self.duels_scores)

        if voting_rule in VotingRulesConstants.ONE_ROUND:
            if voting_rule == VotingRulesConstants.APPROVAL:
                result = func(
                    self.electors,
                    self.candidates,
                    VotingRulesConstants.APPROVAL_GAP_COEF,
                    self.duels_scores if self.tie_breaker_activated else None,
                )
            else:
                result = func(
                    self.electors,
                    self.candidates,
                    self.duels_scores if self.tie_breaker_activated else None,
                )

        if voting_rule in VotingRulesConstants.MULTI_ROUND:
            result = func(self.electors, self.candidates)

        self.results[voting_rule] = result

    def choose_winner(self, voting_rule: str) -&gt; Union[Candidate, None]:
        &#34;&#34;&#34;Retourne le gagnant d&#39;après la règle de vote voting_rule.

        Args:
            voting_rule (str): Une constante correspondant à une règle de vote.

        Returns:
            Union[Candidate, None]: Un candidat-gagnant. Peut retourner `None` dans le cas de la règle de vote *Condorcet simple*
                ou si le classement associé à voting_rule est vide.
        &#34;&#34;&#34;
        if voting_rule not in self.results:
            self.apply_voting_rule(voting_rule)

        if not len(self.results[voting_rule]):
            return None

        if voting_rule in VotingRulesConstants.MULTI_ROUND:
            return self.results[voting_rule][-1][0]

        if voting_rule == VotingRulesConstants.CONDORCET_SIMPLE:
            return self.choose_condorcet_winner()

        return self.results[voting_rule][0]

    def choose_condorcet_winner(self) -&gt; Union[Candidate, None]:
        &#34;&#34;&#34;Retourne le gagnant d&#39;après le système de vote &#34;Condorcet simple&#34;. 
        Le gagnant est un candidat qui bat tous les autres en duel.

        Returns:
            Union[Candidate, None]: Un candidat du Condorcet s&#39;il existe, sinon`None`.
        &#34;&#34;&#34;

        fst_candidate = self.results[VotingRulesConstants.CONDORCET_SIMPLE][0]
        score = fst_candidate.scores[VotingRulesConstants.CONDORCET_SIMPLE]
        return fst_candidate if score == len(self.candidates) - 1 else None

    def _define_ranking(self) -&gt; None:
        &#34;&#34;&#34;Fait classer les candidats pour chaque électeur. Doit être appelée uniquement quand tous les candidats ont été ajoutés.&#34;&#34;&#34;

        for elector in self.electors:
            elector.rank_candidates(self.candidates)

    def calc_results(self, imported: Optional[bool] = False) -&gt; None:
        &#34;&#34;&#34;Calcule les résultats d&#39;une élection : calcule les duels entre les candidats, 
        attribue des scores aux candidats, et calcule le classement des candidats pour chaque règle de vote choisie.

        Args:
            imported (bool): True si les données ont été importés. Si oui, 
                ne calcule pas les duels et les scores des candidats pour chaque règle de vote choisie. 
                Ils sont importés. Cepedant, un calcul des classements est effectué.
        &#34;&#34;&#34;

        if imported:
            # Les duels sont importés dans sqlite.ImportData
            self.set_results()
            return

        self.duels_scores = set_duels_scores(self.electors, self.candidates)
        for voting_rule in self.results:
            self.apply_voting_rule(voting_rule)

    def set_avg_electors_position(self) -&gt; None:
        &#34;&#34;&#34;Calcule la position moyenne des électeurs. Uniquement la division est faite. 
        La somme de toutes les positions est déjà stockée.&#34;&#34;&#34;

        x_avg, y_avg = self.average_position_electors
        x_avg /= len(self.electors)
        y_avg /= len(self.electors)
        self.average_position_electors = (x_avg, y_avg)

    def _calc_proportion_satisfaction(self) -&gt; None:
        &#34;&#34;&#34;Calcule la distance maximale entre la position moyenne des électeurs et la position
            de chaque candidat et la stock dans `Election.proportion_satisfaction`.
        &#34;&#34;&#34;

        proportion = 0
        for candidate in self.candidates:
            dist_cand_electors = self._calc_distance(
                candidate.position, self.average_position_electors
            )
            proportion = max(proportion, dist_cand_electors)
        self.proportion_satisfaction = proportion

    def calc_satisfaction(self, candidate: Candidate) -&gt; float:
        &#34;&#34;&#34;Calcule le pourcentage de la population qui est satisfait par une victoire du candidat candidate dans une élection.  
        **Algorithme**:  
            - Calcule la distance du candidat par rapport a la position moyenne des électeurs  
            - Calcule la valeur absolue de la différence de cette distance moins la distance maximale (`proportion_satisfaction`)  
            - Calcule le pourcentage de satisfaction selon cette valeur absolue divisée par la valeur maximale (`proportion_satisfaction`)  
            - Renvoie ce pourcentage (plus la distance au point moyen est faible, plus le pourcentage sera élevé et inversement)  

        Args:
            candidate (people.candidate.Candidate): Un candidat-gagnant.

        Returns:
            float: Le pourcentage de satisfaction de la population.
        &#34;&#34;&#34;

        diff = abs(
            self._calc_distance(candidate.position, self.average_position_electors)
            - self.proportion_satisfaction
        )
        percentage = (
            diff / self.proportion_satisfaction * 100
            if self.proportion_satisfaction != 0
            else 0
        )
        return percentage

    def set_results(self) -&gt; None:
        &#34;&#34;&#34;Calcule un classement des candidats selon leurs scores (les scores sont déjà attribués à chaque candidat). 
        Utilisée lors de l&#39;importation des données. MAJ d&#39;un dictionnaire results. 
        La fonction ne fait rien s&#39;il n&#39;existe pas au moins un électeur et un candidat.
        &#34;&#34;&#34;

        if not self.has_electors_candidates():
            return
        # Assuming every candidate has the same voting_rules
        candidate = self.candidates[0]
        keys = candidate.scores.keys()

        duels = self.duels_scores if self.tie_breaker_activated else None
        for voting_rule in keys:
            if voting_rule in VotingRulesConstants.ONE_ROUND:
                result = sort_cand_by_value(self.candidates, voting_rule, nb_electors=len(self.electors), duels=duels)
                self.results[voting_rule] = result

            if voting_rule in VotingRulesConstants.MULTI_ROUND:
                self.results[voting_rule] = [None] * len(candidate.scores[voting_rule])

                for round in range(len(candidate.scores[voting_rule])):
                    result = sort_cand_by_round(self.candidates, voting_rule, round)
                    self.results[voting_rule][round] = result

            if voting_rule in VotingRulesConstants.CONDORCET:
                sort_asc = (
                    True
                    if voting_rule == VotingRulesConstants.CONDORCET_SIMPSON
                    else False
                )
                result = sort_cand_by_value(self.candidates, voting_rule, nb_electors=len(
                    self.electors), duels=None, scores_asc=sort_asc)
                self.results[voting_rule] = result

    def start_election(self, imported: Optional[bool] = False, chosen_voting_rules: List[str] = None) -&gt; None:
        &#34;&#34;&#34;Commence une élection. Fait tout les calculs nécessaires:  
            - Chaque électeur définit son classement des candidats  
            - MAJ de la position moyenne des électeurs  
            - Calcule le taux de satisfaction  
            - Si les sondages sont activés, MAJ les données pour chaque direction de la carte politique  
            - Si la démocratie liquide est activée, fait les délégations  
            - Initialise un dictionnaire results avec des règles de vote choisies  
            - Calcule les résultats  

        Args:
            imported (Optional[bool]): `True` si les données ont été importées, sinon `False`. 
                Cf. `Election.calc_results()` &lt;electoral_systems.election.Election&gt;
            chosen_voting_rules (Set[str]): Une liste des constantes des règles de vote choisies.
        &#34;&#34;&#34;

        self._define_ranking()
        self.set_avg_electors_position()
        self._calc_proportion_satisfaction()

        # Set data for polls
        if self.nb_polls:
            set_avg_electors_positions(self.directions_data)
            set_std_deviation(self.directions_data, len(self.electors))
        if self.liquid_democracy_activated:
            self._make_delegations()
        if chosen_voting_rules:
            self._init_results_keys(chosen_voting_rules)

        self.calc_results(imported)

    def _make_delegations(self) -&gt; None:
        &#34;&#34;&#34;Pour une démocratie liquide. Pour chaque électeur décide s&#39;il fera une délégation de son vote.
        Si oui, MAJ des données de son délégataire et de lui-même.&#34;&#34;&#34;

        for elector in self.electors:
            proba = 1 - elector.knowledge
            # Pas de délégation
            if random() &gt; proba:
                continue
            # Faire une délégation
            possible_delegees = choose_possible_delegees(
                self.electors, elector
            )
            delegee = choose_delegee(possible_delegees)
            if delegee is None:
                continue
            delegee.weight += elector.weight
            elector.weight = 0

    def conduct_poll(self) -&gt; None:
        &#34;&#34;&#34;Fait un nouveau sondage. Tout d&#39;abord les candidats changent leurs positions. 
        Les électeurs redéfinissent leur classement des candidats. Puis les électeurs changent leur classement. 
        Cf. `electoral_systems.extensions.polls` pour les détails.&#34;&#34;&#34;

        voting_rule = self.poll_voting_rule
        winner = self.choose_winner(voting_rule)
        ranking = self.results[voting_rule]

        # Des candidats changent leurs positions politiques
        change_position_candidates(
            self.candidates,
            winner,
            ranking,
            self.directions_data,
            self.generation_constants[RandomConstants.TRAVEL_DIST],
        )

        # Des électeurs changent leur classement
        self._define_ranking()

        # Des électeurs s&#39;adaptent en changeant leur classement intelligemment
        score_winner = winner.scores[voting_rule]
        change_ranking_electors(
            self.electors,
            score_winner,
            voting_rule,
            VotingRulesConstants.APPROVAL_GAP_COEF,
        )
        # Recalcule des résultats
        self.calc_results()

    def delete_all_data(self) -&gt; None:
        &#34;&#34;&#34;Supprime toutes les données d&#39;une élection. Relance les itérateurs-générateurs des noms, prénoms, IDs.&#34;&#34;&#34;
        self.electors.clear()
        self.candidates.clear()
        self.results.clear()

        self.first_name_iter.restart()
        self.last_name_iter.restart()
        self.id_iter.restart()

        self.directions_data.clear()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="electoral_systems.election.Election"><code class="flex name class">
<span>class <span class="ident">Election</span></span>
</code></dt>
<dd>
<div class="desc"><p>Une classe Singleton qui contient toutes les données nécessaires à une élection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Election(metaclass=Singleton):
    &#34;&#34;&#34;Une classe Singleton qui contient toutes les données nécessaires à une élection.&#34;&#34;&#34;

    def __init__(self):
        super().__init__()
        self.electors:List[Elector] = []
        &#34;&#34;&#34;Une liste qui stocke tous les électeurs qui participent dans une élection.&#34;&#34;&#34;

        self.candidates = []
        &#34;&#34;&#34;Une liste qui stocke tous les candidats qui participent dans une élection.&#34;&#34;&#34;

        self.first_name_iter = NameIterator()
        &#34;&#34;&#34;Un itérateur qui génére des prénoms des candidats (uniquement pour les données générées aléatoirement)&#34;&#34;&#34;

        self.last_name_iter = NameIterator()
        &#34;&#34;&#34;Un itérateur qui génére des noms des candidats (uniquement pour les données générées aléatoirement)&#34;&#34;&#34;

        self.id_iter = IdIterator(0)
        &#34;&#34;&#34;Un itérateur qui génére des IDs des candidats et des électeurs.&#34;&#34;&#34;

        # Stocke les resultats
        self.results:Dict[str, List[Candidate]] = dict()
        &#34;&#34;&#34;Un dictionnaire qui stocke un classement des candidats (dans l&#39;ordre décroissant) pour chaque règle de vote choisie.&#34;&#34;&#34;

        # Stocke les duels
        self.duels_scores:duels_type = dict()
        &#34;&#34;&#34;Un dictionnaire qui stocke les résultats des duels entre les candidats.&#34;&#34;&#34;

        # Pour la satisfaction
        self.average_position_electors:tuple[float, float] = (0, 0)
        self.proportion_satisfaction:float = 0
        &#34;&#34;&#34;La distance maximale entre la position moyenne des électeurs et la position de chaque candidat.&#34;&#34;&#34;

        # Init les constantes
        self.set_default_settings()

    def set_default_settings(self) -&gt; None:
        &#34;&#34;&#34;Initialise les réglages par défaut.&#34;&#34;&#34;

        # Nb de sondages à faire
        self.nb_polls:int = 0
        &#34;&#34;&#34;Un nombre des sondages à faire&#34;&#34;&#34;

        # Active/désactive la démocratie liquide
        self.liquid_democracy_activated = False

        # Une règle de vote pour les sondages
        self.poll_voting_rule = VotingRulesConstants.PLURALITY_SIMPLE

        # Active/désactive un tie-break selon les duels
        self.tie_breaker_activated = True

        # Les constantes de la génération des données
        self.generation_constants = dict()
        for type, default_value in RandomConstants.DEFAULT_VALUES.items():
            self.generation_constants[type] = default_value

        # Pour les sondages uniquement. Stocke les données pour chaque direction (division) de la carte politique
        self.directions_data = get_default_directions_data()

    def _init_results_keys(self, set_keys: Set[str]) -&gt; None:
        &#34;&#34;&#34;Initialiser des clés du dictionnaire `results` avec des constantes associées aux règles du vote choisies.
        Les valeurs sont rémies à `None`.
        &#34;&#34;&#34;

        for key in set_keys:
            self.results[key] = None

    def _calc_distance(self, point1: tuple[float, float], point2: tuple[float, float]) -&gt; float:
        &#34;&#34;&#34;Calcule la distance euclidienne entre 2 points.

        Args:
            point1 (tuple[float, float]): position sur la carte politique
            point2 (tuple[float, float]): position sur la carte politique
        Returns:
            float: La distance euclidienne entre 2 points.
        &#34;&#34;&#34;
        x1, y1 = point1
        x2, y2 = point2
        return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)

    def has_electors_candidates(self) -&gt; bool:
        &#34;&#34;&#34;Vérifie qu&#39;il existe au moins un électeur et un candidat dans une élection.

        Returns:
            bool: `True` s&#39;il existe au moins un électeur et un candidat dans une élection, sinon `False`.
        &#34;&#34;&#34;

        if not self.electors and not self.candidates:
            return False
        return True

    def add_elector_import(self, new_elector: Elector) -&gt; None:
        &#34;&#34;&#34;Ajoute un électeur dont les données sont déjà initialisées. 
        Si les sondages sont activés, MAJ les données sur les directions de la carte politique. 
        MAJ les données sur la position moyenne de tous les électeurs participants à l&#39;élection. 
        Utilisée lors d&#39;une importation des données.

        Args:
            new_elector (people.elector.Elector): Un nouvel électeur.
        &#34;&#34;&#34;

        if self.nb_polls:
            add_elector_data(self.directions_data, new_elector)

        x, y = new_elector.position
        x_avg, y_avg = self.average_position_electors
        x_avg, y_avg = x_avg + x, y_avg + y
        self.average_position_electors = (x_avg, y_avg)

        self.electors.append(new_elector)

    def add_elector(self, position: tuple[float, float]) -&gt; None:
        &#34;&#34;&#34;Ajoute un nouvel électeur dans une élection avec sa position position. 
        Si les sondages sont activés, MAJ les données sur les directions de la carte politique. 
        MAJ les données sur la position moyenne de tous les électeurs participants à l&#39;élection.

        Args:
            position (tuple[float, float]): La position d&#39;un électeur sur la carte politique. 
                Chaque coordonnée doit être bornée entre -1 et 1.
        &#34;&#34;&#34;

        knowledge_const = self.generation_constants[RandomConstants.KNOWLEDGE]
        new_elector = Elector(
            id=next(self.id_iter), position=position, knowledge_const=knowledge_const
        )
        x, y = new_elector.position

        if self.nb_polls:
            add_elector_data(self.directions_data, new_elector)

        # All electors average
        x_avg, y_avg = self.average_position_electors
        x_avg, y_avg = x_avg + x, y_avg + y
        self.average_position_electors = (x_avg, y_avg)
        self.electors.append(new_elector)

    def add_candidate_import(self, new_candidate: Candidate) -&gt; None:
        &#34;&#34;&#34;Ajoute un candidat dont les données sont déjà initialisées. 
        Si les sondages sont activés, MAJ les données sur les directions de la carte politique. 
        Utilisée lors d&#39;une importation des données.

        Args:
            new_elector (people.elector.Elector): Un nouvel électeur.
        &#34;&#34;&#34;

        self.candidates.append(new_candidate)
        if self.nb_polls:
            add_candidate_data(self.directions_data, new_candidate)

    def add_candidate(self, position: tuple[float, float], first_name: Optional[str] = &#34;&#34;, last_name: Optional[str] = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;Ajoute un nouveau candidat dans une élection avec sa position position, 
        et éventuellement son nom (`last_name`) et son prénom (`first_name`). Si les sondages sont activés, 
        MAJ les données sur les directions de la carte politique.

        Args:
            position (tuple[float, float]): La position d&#39;un candidat sur la carte politique. 
                Chaque coordonnée doit être bornée entre -1 et 1.
            first_name (Optional[str]): Le prénom d&#39;un candidat.
            last_name (Optional[str]): Le nom d&#39;un candidat.
        &#34;&#34;&#34;

        dogmat_const = self.generation_constants[RandomConstants.DOGMATISM]
        oppos_const = self.generation_constants[RandomConstants.OPPOSITION]

        first_name = next(self.first_name_iter) if not first_name else first_name
        last_name = next(self.last_name_iter) if not last_name else last_name

        new_candidate = Candidate(
            id=next(self.id_iter),
            position=position,
            first_name=first_name,
            last_name=last_name,
            dogmatism_const=dogmat_const,
            opposition_const=oppos_const,
        )
        if self.nb_polls:
            add_candidate_data(self.directions_data, new_candidate)

        self.candidates.append(new_candidate)

    def apply_voting_rule(self, voting_rule: str) -&gt; None:
        &#34;&#34;&#34;Applique une règle de vote voting_rule. 
        Remplit la case correspondante à voting_rule du dictionnaire results avec une liste (un classement) des candidats. 
        La fonction est appliquée uniquement s&#39;il existe au moins un électeur et un candidat, sinon elle ne fait rien.

        Args:
            voting_rule (str): Une constante correspondant à une règle de vote.
        &#34;&#34;&#34;

        if not self.has_electors_candidates():
            return

        result = []
        func = VotingRulesConstants.VOTING_RULES_FUNC[voting_rule]

        if voting_rule in VotingRulesConstants.CONDORCET:
            result = func(self.electors, self.candidates, self.duels_scores)

        if voting_rule in VotingRulesConstants.ONE_ROUND:
            if voting_rule == VotingRulesConstants.APPROVAL:
                result = func(
                    self.electors,
                    self.candidates,
                    VotingRulesConstants.APPROVAL_GAP_COEF,
                    self.duels_scores if self.tie_breaker_activated else None,
                )
            else:
                result = func(
                    self.electors,
                    self.candidates,
                    self.duels_scores if self.tie_breaker_activated else None,
                )

        if voting_rule in VotingRulesConstants.MULTI_ROUND:
            result = func(self.electors, self.candidates)

        self.results[voting_rule] = result

    def choose_winner(self, voting_rule: str) -&gt; Union[Candidate, None]:
        &#34;&#34;&#34;Retourne le gagnant d&#39;après la règle de vote voting_rule.

        Args:
            voting_rule (str): Une constante correspondant à une règle de vote.

        Returns:
            Union[Candidate, None]: Un candidat-gagnant. Peut retourner `None` dans le cas de la règle de vote *Condorcet simple*
                ou si le classement associé à voting_rule est vide.
        &#34;&#34;&#34;
        if voting_rule not in self.results:
            self.apply_voting_rule(voting_rule)

        if not len(self.results[voting_rule]):
            return None

        if voting_rule in VotingRulesConstants.MULTI_ROUND:
            return self.results[voting_rule][-1][0]

        if voting_rule == VotingRulesConstants.CONDORCET_SIMPLE:
            return self.choose_condorcet_winner()

        return self.results[voting_rule][0]

    def choose_condorcet_winner(self) -&gt; Union[Candidate, None]:
        &#34;&#34;&#34;Retourne le gagnant d&#39;après le système de vote &#34;Condorcet simple&#34;. 
        Le gagnant est un candidat qui bat tous les autres en duel.

        Returns:
            Union[Candidate, None]: Un candidat du Condorcet s&#39;il existe, sinon`None`.
        &#34;&#34;&#34;

        fst_candidate = self.results[VotingRulesConstants.CONDORCET_SIMPLE][0]
        score = fst_candidate.scores[VotingRulesConstants.CONDORCET_SIMPLE]
        return fst_candidate if score == len(self.candidates) - 1 else None

    def _define_ranking(self) -&gt; None:
        &#34;&#34;&#34;Fait classer les candidats pour chaque électeur. Doit être appelée uniquement quand tous les candidats ont été ajoutés.&#34;&#34;&#34;

        for elector in self.electors:
            elector.rank_candidates(self.candidates)

    def calc_results(self, imported: Optional[bool] = False) -&gt; None:
        &#34;&#34;&#34;Calcule les résultats d&#39;une élection : calcule les duels entre les candidats, 
        attribue des scores aux candidats, et calcule le classement des candidats pour chaque règle de vote choisie.

        Args:
            imported (bool): True si les données ont été importés. Si oui, 
                ne calcule pas les duels et les scores des candidats pour chaque règle de vote choisie. 
                Ils sont importés. Cepedant, un calcul des classements est effectué.
        &#34;&#34;&#34;

        if imported:
            # Les duels sont importés dans sqlite.ImportData
            self.set_results()
            return

        self.duels_scores = set_duels_scores(self.electors, self.candidates)
        for voting_rule in self.results:
            self.apply_voting_rule(voting_rule)

    def set_avg_electors_position(self) -&gt; None:
        &#34;&#34;&#34;Calcule la position moyenne des électeurs. Uniquement la division est faite. 
        La somme de toutes les positions est déjà stockée.&#34;&#34;&#34;

        x_avg, y_avg = self.average_position_electors
        x_avg /= len(self.electors)
        y_avg /= len(self.electors)
        self.average_position_electors = (x_avg, y_avg)

    def _calc_proportion_satisfaction(self) -&gt; None:
        &#34;&#34;&#34;Calcule la distance maximale entre la position moyenne des électeurs et la position
            de chaque candidat et la stock dans `Election.proportion_satisfaction`.
        &#34;&#34;&#34;

        proportion = 0
        for candidate in self.candidates:
            dist_cand_electors = self._calc_distance(
                candidate.position, self.average_position_electors
            )
            proportion = max(proportion, dist_cand_electors)
        self.proportion_satisfaction = proportion

    def calc_satisfaction(self, candidate: Candidate) -&gt; float:
        &#34;&#34;&#34;Calcule le pourcentage de la population qui est satisfait par une victoire du candidat candidate dans une élection.  
        **Algorithme**:  
            - Calcule la distance du candidat par rapport a la position moyenne des électeurs  
            - Calcule la valeur absolue de la différence de cette distance moins la distance maximale (`proportion_satisfaction`)  
            - Calcule le pourcentage de satisfaction selon cette valeur absolue divisée par la valeur maximale (`proportion_satisfaction`)  
            - Renvoie ce pourcentage (plus la distance au point moyen est faible, plus le pourcentage sera élevé et inversement)  

        Args:
            candidate (people.candidate.Candidate): Un candidat-gagnant.

        Returns:
            float: Le pourcentage de satisfaction de la population.
        &#34;&#34;&#34;

        diff = abs(
            self._calc_distance(candidate.position, self.average_position_electors)
            - self.proportion_satisfaction
        )
        percentage = (
            diff / self.proportion_satisfaction * 100
            if self.proportion_satisfaction != 0
            else 0
        )
        return percentage

    def set_results(self) -&gt; None:
        &#34;&#34;&#34;Calcule un classement des candidats selon leurs scores (les scores sont déjà attribués à chaque candidat). 
        Utilisée lors de l&#39;importation des données. MAJ d&#39;un dictionnaire results. 
        La fonction ne fait rien s&#39;il n&#39;existe pas au moins un électeur et un candidat.
        &#34;&#34;&#34;

        if not self.has_electors_candidates():
            return
        # Assuming every candidate has the same voting_rules
        candidate = self.candidates[0]
        keys = candidate.scores.keys()

        duels = self.duels_scores if self.tie_breaker_activated else None
        for voting_rule in keys:
            if voting_rule in VotingRulesConstants.ONE_ROUND:
                result = sort_cand_by_value(self.candidates, voting_rule, nb_electors=len(self.electors), duels=duels)
                self.results[voting_rule] = result

            if voting_rule in VotingRulesConstants.MULTI_ROUND:
                self.results[voting_rule] = [None] * len(candidate.scores[voting_rule])

                for round in range(len(candidate.scores[voting_rule])):
                    result = sort_cand_by_round(self.candidates, voting_rule, round)
                    self.results[voting_rule][round] = result

            if voting_rule in VotingRulesConstants.CONDORCET:
                sort_asc = (
                    True
                    if voting_rule == VotingRulesConstants.CONDORCET_SIMPSON
                    else False
                )
                result = sort_cand_by_value(self.candidates, voting_rule, nb_electors=len(
                    self.electors), duels=None, scores_asc=sort_asc)
                self.results[voting_rule] = result

    def start_election(self, imported: Optional[bool] = False, chosen_voting_rules: List[str] = None) -&gt; None:
        &#34;&#34;&#34;Commence une élection. Fait tout les calculs nécessaires:  
            - Chaque électeur définit son classement des candidats  
            - MAJ de la position moyenne des électeurs  
            - Calcule le taux de satisfaction  
            - Si les sondages sont activés, MAJ les données pour chaque direction de la carte politique  
            - Si la démocratie liquide est activée, fait les délégations  
            - Initialise un dictionnaire results avec des règles de vote choisies  
            - Calcule les résultats  

        Args:
            imported (Optional[bool]): `True` si les données ont été importées, sinon `False`. 
                Cf. `Election.calc_results()` &lt;electoral_systems.election.Election&gt;
            chosen_voting_rules (Set[str]): Une liste des constantes des règles de vote choisies.
        &#34;&#34;&#34;

        self._define_ranking()
        self.set_avg_electors_position()
        self._calc_proportion_satisfaction()

        # Set data for polls
        if self.nb_polls:
            set_avg_electors_positions(self.directions_data)
            set_std_deviation(self.directions_data, len(self.electors))
        if self.liquid_democracy_activated:
            self._make_delegations()
        if chosen_voting_rules:
            self._init_results_keys(chosen_voting_rules)

        self.calc_results(imported)

    def _make_delegations(self) -&gt; None:
        &#34;&#34;&#34;Pour une démocratie liquide. Pour chaque électeur décide s&#39;il fera une délégation de son vote.
        Si oui, MAJ des données de son délégataire et de lui-même.&#34;&#34;&#34;

        for elector in self.electors:
            proba = 1 - elector.knowledge
            # Pas de délégation
            if random() &gt; proba:
                continue
            # Faire une délégation
            possible_delegees = choose_possible_delegees(
                self.electors, elector
            )
            delegee = choose_delegee(possible_delegees)
            if delegee is None:
                continue
            delegee.weight += elector.weight
            elector.weight = 0

    def conduct_poll(self) -&gt; None:
        &#34;&#34;&#34;Fait un nouveau sondage. Tout d&#39;abord les candidats changent leurs positions. 
        Les électeurs redéfinissent leur classement des candidats. Puis les électeurs changent leur classement. 
        Cf. `electoral_systems.extensions.polls` pour les détails.&#34;&#34;&#34;

        voting_rule = self.poll_voting_rule
        winner = self.choose_winner(voting_rule)
        ranking = self.results[voting_rule]

        # Des candidats changent leurs positions politiques
        change_position_candidates(
            self.candidates,
            winner,
            ranking,
            self.directions_data,
            self.generation_constants[RandomConstants.TRAVEL_DIST],
        )

        # Des électeurs changent leur classement
        self._define_ranking()

        # Des électeurs s&#39;adaptent en changeant leur classement intelligemment
        score_winner = winner.scores[voting_rule]
        change_ranking_electors(
            self.electors,
            score_winner,
            voting_rule,
            VotingRulesConstants.APPROVAL_GAP_COEF,
        )
        # Recalcule des résultats
        self.calc_results()

    def delete_all_data(self) -&gt; None:
        &#34;&#34;&#34;Supprime toutes les données d&#39;une élection. Relance les itérateurs-générateurs des noms, prénoms, IDs.&#34;&#34;&#34;
        self.electors.clear()
        self.candidates.clear()
        self.results.clear()

        self.first_name_iter.restart()
        self.last_name_iter.restart()
        self.id_iter.restart()

        self.directions_data.clear()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="electoral_systems.election.Election.candidates"><code class="name">var <span class="ident">candidates</span></code></dt>
<dd>
<div class="desc"><p>Une liste qui stocke tous les candidats qui participent dans une élection.</p></div>
</dd>
<dt id="electoral_systems.election.Election.duels_scores"><code class="name">var <span class="ident">duels_scores</span></code></dt>
<dd>
<div class="desc"><p>Un dictionnaire qui stocke les résultats des duels entre les candidats.</p></div>
</dd>
<dt id="electoral_systems.election.Election.electors"><code class="name">var <span class="ident">electors</span></code></dt>
<dd>
<div class="desc"><p>Une liste qui stocke tous les électeurs qui participent dans une élection.</p></div>
</dd>
<dt id="electoral_systems.election.Election.first_name_iter"><code class="name">var <span class="ident">first_name_iter</span></code></dt>
<dd>
<div class="desc"><p>Un itérateur qui génére des prénoms des candidats (uniquement pour les données générées aléatoirement)</p></div>
</dd>
<dt id="electoral_systems.election.Election.id_iter"><code class="name">var <span class="ident">id_iter</span></code></dt>
<dd>
<div class="desc"><p>Un itérateur qui génére des IDs des candidats et des électeurs.</p></div>
</dd>
<dt id="electoral_systems.election.Election.last_name_iter"><code class="name">var <span class="ident">last_name_iter</span></code></dt>
<dd>
<div class="desc"><p>Un itérateur qui génére des noms des candidats (uniquement pour les données générées aléatoirement)</p></div>
</dd>
<dt id="electoral_systems.election.Election.proportion_satisfaction"><code class="name">var <span class="ident">proportion_satisfaction</span></code></dt>
<dd>
<div class="desc"><p>La distance maximale entre la position moyenne des électeurs et la position de chaque candidat.</p></div>
</dd>
<dt id="electoral_systems.election.Election.results"><code class="name">var <span class="ident">results</span></code></dt>
<dd>
<div class="desc"><p>Un dictionnaire qui stocke un classement des candidats (dans l'ordre décroissant) pour chaque règle de vote choisie.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="electoral_systems.election.Election._calc_distance"><code class="name flex">
<span>def <span class="ident">_calc_distance</span></span>(<span>self, point1: tuple[float, float], point2: tuple[float, float]) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calcule la distance euclidienne entre 2 points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point1</code></strong> :&ensp;<code>tuple[float, float]</code></dt>
<dd>position sur la carte politique</dd>
<dt><strong><code>point2</code></strong> :&ensp;<code>tuple[float, float]</code></dt>
<dd>position sur la carte politique</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>La distance euclidienne entre 2 points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _calc_distance(self, point1: tuple[float, float], point2: tuple[float, float]) -&gt; float:
    &#34;&#34;&#34;Calcule la distance euclidienne entre 2 points.

    Args:
        point1 (tuple[float, float]): position sur la carte politique
        point2 (tuple[float, float]): position sur la carte politique
    Returns:
        float: La distance euclidienne entre 2 points.
    &#34;&#34;&#34;
    x1, y1 = point1
    x2, y2 = point2
    return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election._calc_proportion_satisfaction"><code class="name flex">
<span>def <span class="ident">_calc_proportion_satisfaction</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calcule la distance maximale entre la position moyenne des électeurs et la position
de chaque candidat et la stock dans <code><a title="electoral_systems.election.Election.proportion_satisfaction" href="#electoral_systems.election.Election.proportion_satisfaction">Election.proportion_satisfaction</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _calc_proportion_satisfaction(self) -&gt; None:
    &#34;&#34;&#34;Calcule la distance maximale entre la position moyenne des électeurs et la position
        de chaque candidat et la stock dans `Election.proportion_satisfaction`.
    &#34;&#34;&#34;

    proportion = 0
    for candidate in self.candidates:
        dist_cand_electors = self._calc_distance(
            candidate.position, self.average_position_electors
        )
        proportion = max(proportion, dist_cand_electors)
    self.proportion_satisfaction = proportion</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election._define_ranking"><code class="name flex">
<span>def <span class="ident">_define_ranking</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Fait classer les candidats pour chaque électeur. Doit être appelée uniquement quand tous les candidats ont été ajoutés.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _define_ranking(self) -&gt; None:
    &#34;&#34;&#34;Fait classer les candidats pour chaque électeur. Doit être appelée uniquement quand tous les candidats ont été ajoutés.&#34;&#34;&#34;

    for elector in self.electors:
        elector.rank_candidates(self.candidates)</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election._init_results_keys"><code class="name flex">
<span>def <span class="ident">_init_results_keys</span></span>(<span>self, set_keys: Set[str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialiser des clés du dictionnaire <code>results</code> avec des constantes associées aux règles du vote choisies.
Les valeurs sont rémies à <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _init_results_keys(self, set_keys: Set[str]) -&gt; None:
    &#34;&#34;&#34;Initialiser des clés du dictionnaire `results` avec des constantes associées aux règles du vote choisies.
    Les valeurs sont rémies à `None`.
    &#34;&#34;&#34;

    for key in set_keys:
        self.results[key] = None</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election._make_delegations"><code class="name flex">
<span>def <span class="ident">_make_delegations</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Pour une démocratie liquide. Pour chaque électeur décide s'il fera une délégation de son vote.
Si oui, MAJ des données de son délégataire et de lui-même.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _make_delegations(self) -&gt; None:
    &#34;&#34;&#34;Pour une démocratie liquide. Pour chaque électeur décide s&#39;il fera une délégation de son vote.
    Si oui, MAJ des données de son délégataire et de lui-même.&#34;&#34;&#34;

    for elector in self.electors:
        proba = 1 - elector.knowledge
        # Pas de délégation
        if random() &gt; proba:
            continue
        # Faire une délégation
        possible_delegees = choose_possible_delegees(
            self.electors, elector
        )
        delegee = choose_delegee(possible_delegees)
        if delegee is None:
            continue
        delegee.weight += elector.weight
        elector.weight = 0</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.add_candidate"><code class="name flex">
<span>def <span class="ident">add_candidate</span></span>(<span>self, position: tuple[float, float], first_name: Optional[str] = '', last_name: Optional[str] = '') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Ajoute un nouveau candidat dans une élection avec sa position position,
et éventuellement son nom (<code>last_name</code>) et son prénom (<code>first_name</code>). Si les sondages sont activés,
MAJ les données sur les directions de la carte politique.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>tuple[float, float]</code></dt>
<dd>La position d'un candidat sur la carte politique.
Chaque coordonnée doit être bornée entre -1 et 1.</dd>
<dt><strong><code>first_name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Le prénom d'un candidat.</dd>
<dt><strong><code>last_name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Le nom d'un candidat.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_candidate(self, position: tuple[float, float], first_name: Optional[str] = &#34;&#34;, last_name: Optional[str] = &#34;&#34;) -&gt; None:
    &#34;&#34;&#34;Ajoute un nouveau candidat dans une élection avec sa position position, 
    et éventuellement son nom (`last_name`) et son prénom (`first_name`). Si les sondages sont activés, 
    MAJ les données sur les directions de la carte politique.

    Args:
        position (tuple[float, float]): La position d&#39;un candidat sur la carte politique. 
            Chaque coordonnée doit être bornée entre -1 et 1.
        first_name (Optional[str]): Le prénom d&#39;un candidat.
        last_name (Optional[str]): Le nom d&#39;un candidat.
    &#34;&#34;&#34;

    dogmat_const = self.generation_constants[RandomConstants.DOGMATISM]
    oppos_const = self.generation_constants[RandomConstants.OPPOSITION]

    first_name = next(self.first_name_iter) if not first_name else first_name
    last_name = next(self.last_name_iter) if not last_name else last_name

    new_candidate = Candidate(
        id=next(self.id_iter),
        position=position,
        first_name=first_name,
        last_name=last_name,
        dogmatism_const=dogmat_const,
        opposition_const=oppos_const,
    )
    if self.nb_polls:
        add_candidate_data(self.directions_data, new_candidate)

    self.candidates.append(new_candidate)</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.add_candidate_import"><code class="name flex">
<span>def <span class="ident">add_candidate_import</span></span>(<span>self, new_candidate: people.candidate.Candidate) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Ajoute un candidat dont les données sont déjà initialisées.
Si les sondages sont activés, MAJ les données sur les directions de la carte politique.
Utilisée lors d'une importation des données.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_elector</code></strong> :&ensp;<code>people.elector.Elector</code></dt>
<dd>Un nouvel électeur.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_candidate_import(self, new_candidate: Candidate) -&gt; None:
    &#34;&#34;&#34;Ajoute un candidat dont les données sont déjà initialisées. 
    Si les sondages sont activés, MAJ les données sur les directions de la carte politique. 
    Utilisée lors d&#39;une importation des données.

    Args:
        new_elector (people.elector.Elector): Un nouvel électeur.
    &#34;&#34;&#34;

    self.candidates.append(new_candidate)
    if self.nb_polls:
        add_candidate_data(self.directions_data, new_candidate)</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.add_elector"><code class="name flex">
<span>def <span class="ident">add_elector</span></span>(<span>self, position: tuple[float, float]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Ajoute un nouvel électeur dans une élection avec sa position position.
Si les sondages sont activés, MAJ les données sur les directions de la carte politique.
MAJ les données sur la position moyenne de tous les électeurs participants à l'élection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>tuple[float, float]</code></dt>
<dd>La position d'un électeur sur la carte politique.
Chaque coordonnée doit être bornée entre -1 et 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_elector(self, position: tuple[float, float]) -&gt; None:
    &#34;&#34;&#34;Ajoute un nouvel électeur dans une élection avec sa position position. 
    Si les sondages sont activés, MAJ les données sur les directions de la carte politique. 
    MAJ les données sur la position moyenne de tous les électeurs participants à l&#39;élection.

    Args:
        position (tuple[float, float]): La position d&#39;un électeur sur la carte politique. 
            Chaque coordonnée doit être bornée entre -1 et 1.
    &#34;&#34;&#34;

    knowledge_const = self.generation_constants[RandomConstants.KNOWLEDGE]
    new_elector = Elector(
        id=next(self.id_iter), position=position, knowledge_const=knowledge_const
    )
    x, y = new_elector.position

    if self.nb_polls:
        add_elector_data(self.directions_data, new_elector)

    # All electors average
    x_avg, y_avg = self.average_position_electors
    x_avg, y_avg = x_avg + x, y_avg + y
    self.average_position_electors = (x_avg, y_avg)
    self.electors.append(new_elector)</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.add_elector_import"><code class="name flex">
<span>def <span class="ident">add_elector_import</span></span>(<span>self, new_elector: people.elector.Elector) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Ajoute un électeur dont les données sont déjà initialisées.
Si les sondages sont activés, MAJ les données sur les directions de la carte politique.
MAJ les données sur la position moyenne de tous les électeurs participants à l'élection.
Utilisée lors d'une importation des données.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_elector</code></strong> :&ensp;<code>people.elector.Elector</code></dt>
<dd>Un nouvel électeur.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_elector_import(self, new_elector: Elector) -&gt; None:
    &#34;&#34;&#34;Ajoute un électeur dont les données sont déjà initialisées. 
    Si les sondages sont activés, MAJ les données sur les directions de la carte politique. 
    MAJ les données sur la position moyenne de tous les électeurs participants à l&#39;élection. 
    Utilisée lors d&#39;une importation des données.

    Args:
        new_elector (people.elector.Elector): Un nouvel électeur.
    &#34;&#34;&#34;

    if self.nb_polls:
        add_elector_data(self.directions_data, new_elector)

    x, y = new_elector.position
    x_avg, y_avg = self.average_position_electors
    x_avg, y_avg = x_avg + x, y_avg + y
    self.average_position_electors = (x_avg, y_avg)

    self.electors.append(new_elector)</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.apply_voting_rule"><code class="name flex">
<span>def <span class="ident">apply_voting_rule</span></span>(<span>self, voting_rule: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Applique une règle de vote voting_rule.
Remplit la case correspondante à voting_rule du dictionnaire results avec une liste (un classement) des candidats.
La fonction est appliquée uniquement s'il existe au moins un électeur et un candidat, sinon elle ne fait rien.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voting_rule</code></strong> :&ensp;<code>str</code></dt>
<dd>Une constante correspondant à une règle de vote.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_voting_rule(self, voting_rule: str) -&gt; None:
    &#34;&#34;&#34;Applique une règle de vote voting_rule. 
    Remplit la case correspondante à voting_rule du dictionnaire results avec une liste (un classement) des candidats. 
    La fonction est appliquée uniquement s&#39;il existe au moins un électeur et un candidat, sinon elle ne fait rien.

    Args:
        voting_rule (str): Une constante correspondant à une règle de vote.
    &#34;&#34;&#34;

    if not self.has_electors_candidates():
        return

    result = []
    func = VotingRulesConstants.VOTING_RULES_FUNC[voting_rule]

    if voting_rule in VotingRulesConstants.CONDORCET:
        result = func(self.electors, self.candidates, self.duels_scores)

    if voting_rule in VotingRulesConstants.ONE_ROUND:
        if voting_rule == VotingRulesConstants.APPROVAL:
            result = func(
                self.electors,
                self.candidates,
                VotingRulesConstants.APPROVAL_GAP_COEF,
                self.duels_scores if self.tie_breaker_activated else None,
            )
        else:
            result = func(
                self.electors,
                self.candidates,
                self.duels_scores if self.tie_breaker_activated else None,
            )

    if voting_rule in VotingRulesConstants.MULTI_ROUND:
        result = func(self.electors, self.candidates)

    self.results[voting_rule] = result</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.calc_results"><code class="name flex">
<span>def <span class="ident">calc_results</span></span>(<span>self, imported: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calcule les résultats d'une élection : calcule les duels entre les candidats,
attribue des scores aux candidats, et calcule le classement des candidats pour chaque règle de vote choisie.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>imported</code></strong> :&ensp;<code>bool</code></dt>
<dd>True si les données ont été importés. Si oui,
ne calcule pas les duels et les scores des candidats pour chaque règle de vote choisie.
Ils sont importés. Cepedant, un calcul des classements est effectué.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_results(self, imported: Optional[bool] = False) -&gt; None:
    &#34;&#34;&#34;Calcule les résultats d&#39;une élection : calcule les duels entre les candidats, 
    attribue des scores aux candidats, et calcule le classement des candidats pour chaque règle de vote choisie.

    Args:
        imported (bool): True si les données ont été importés. Si oui, 
            ne calcule pas les duels et les scores des candidats pour chaque règle de vote choisie. 
            Ils sont importés. Cepedant, un calcul des classements est effectué.
    &#34;&#34;&#34;

    if imported:
        # Les duels sont importés dans sqlite.ImportData
        self.set_results()
        return

    self.duels_scores = set_duels_scores(self.electors, self.candidates)
    for voting_rule in self.results:
        self.apply_voting_rule(voting_rule)</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.calc_satisfaction"><code class="name flex">
<span>def <span class="ident">calc_satisfaction</span></span>(<span>self, candidate: people.candidate.Candidate) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calcule le pourcentage de la population qui est satisfait par une victoire du candidat candidate dans une élection.<br>
<strong>Algorithme</strong>:<br>
- Calcule la distance du candidat par rapport a la position moyenne des électeurs<br>
- Calcule la valeur absolue de la différence de cette distance moins la distance maximale (<code>proportion_satisfaction</code>)<br>
- Calcule le pourcentage de satisfaction selon cette valeur absolue divisée par la valeur maximale (<code>proportion_satisfaction</code>)<br>
- Renvoie ce pourcentage (plus la distance au point moyen est faible, plus le pourcentage sera élevé et inversement)
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>candidate</code></strong> :&ensp;<code>people.candidate.Candidate</code></dt>
<dd>Un candidat-gagnant.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Le pourcentage de satisfaction de la population.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_satisfaction(self, candidate: Candidate) -&gt; float:
    &#34;&#34;&#34;Calcule le pourcentage de la population qui est satisfait par une victoire du candidat candidate dans une élection.  
    **Algorithme**:  
        - Calcule la distance du candidat par rapport a la position moyenne des électeurs  
        - Calcule la valeur absolue de la différence de cette distance moins la distance maximale (`proportion_satisfaction`)  
        - Calcule le pourcentage de satisfaction selon cette valeur absolue divisée par la valeur maximale (`proportion_satisfaction`)  
        - Renvoie ce pourcentage (plus la distance au point moyen est faible, plus le pourcentage sera élevé et inversement)  

    Args:
        candidate (people.candidate.Candidate): Un candidat-gagnant.

    Returns:
        float: Le pourcentage de satisfaction de la population.
    &#34;&#34;&#34;

    diff = abs(
        self._calc_distance(candidate.position, self.average_position_electors)
        - self.proportion_satisfaction
    )
    percentage = (
        diff / self.proportion_satisfaction * 100
        if self.proportion_satisfaction != 0
        else 0
    )
    return percentage</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.choose_condorcet_winner"><code class="name flex">
<span>def <span class="ident">choose_condorcet_winner</span></span>(<span>self) ‑> Optional[people.candidate.Candidate]</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne le gagnant d'après le système de vote "Condorcet simple".
Le gagnant est un candidat qui bat tous les autres en duel.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[Candidate, None]</code></dt>
<dd>Un candidat du Condorcet s'il existe, sinon<code>None</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_condorcet_winner(self) -&gt; Union[Candidate, None]:
    &#34;&#34;&#34;Retourne le gagnant d&#39;après le système de vote &#34;Condorcet simple&#34;. 
    Le gagnant est un candidat qui bat tous les autres en duel.

    Returns:
        Union[Candidate, None]: Un candidat du Condorcet s&#39;il existe, sinon`None`.
    &#34;&#34;&#34;

    fst_candidate = self.results[VotingRulesConstants.CONDORCET_SIMPLE][0]
    score = fst_candidate.scores[VotingRulesConstants.CONDORCET_SIMPLE]
    return fst_candidate if score == len(self.candidates) - 1 else None</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.choose_winner"><code class="name flex">
<span>def <span class="ident">choose_winner</span></span>(<span>self, voting_rule: str) ‑> Optional[people.candidate.Candidate]</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne le gagnant d'après la règle de vote voting_rule.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voting_rule</code></strong> :&ensp;<code>str</code></dt>
<dd>Une constante correspondant à une règle de vote.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[Candidate, None]</code></dt>
<dd>Un candidat-gagnant. Peut retourner <code>None</code> dans le cas de la règle de vote <em>Condorcet simple</em>
ou si le classement associé à voting_rule est vide.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_winner(self, voting_rule: str) -&gt; Union[Candidate, None]:
    &#34;&#34;&#34;Retourne le gagnant d&#39;après la règle de vote voting_rule.

    Args:
        voting_rule (str): Une constante correspondant à une règle de vote.

    Returns:
        Union[Candidate, None]: Un candidat-gagnant. Peut retourner `None` dans le cas de la règle de vote *Condorcet simple*
            ou si le classement associé à voting_rule est vide.
    &#34;&#34;&#34;
    if voting_rule not in self.results:
        self.apply_voting_rule(voting_rule)

    if not len(self.results[voting_rule]):
        return None

    if voting_rule in VotingRulesConstants.MULTI_ROUND:
        return self.results[voting_rule][-1][0]

    if voting_rule == VotingRulesConstants.CONDORCET_SIMPLE:
        return self.choose_condorcet_winner()

    return self.results[voting_rule][0]</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.conduct_poll"><code class="name flex">
<span>def <span class="ident">conduct_poll</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Fait un nouveau sondage. Tout d'abord les candidats changent leurs positions.
Les électeurs redéfinissent leur classement des candidats. Puis les électeurs changent leur classement.
Cf. <code><a title="electoral_systems.extensions.polls" href="extensions/polls.html">electoral_systems.extensions.polls</a></code> pour les détails.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conduct_poll(self) -&gt; None:
    &#34;&#34;&#34;Fait un nouveau sondage. Tout d&#39;abord les candidats changent leurs positions. 
    Les électeurs redéfinissent leur classement des candidats. Puis les électeurs changent leur classement. 
    Cf. `electoral_systems.extensions.polls` pour les détails.&#34;&#34;&#34;

    voting_rule = self.poll_voting_rule
    winner = self.choose_winner(voting_rule)
    ranking = self.results[voting_rule]

    # Des candidats changent leurs positions politiques
    change_position_candidates(
        self.candidates,
        winner,
        ranking,
        self.directions_data,
        self.generation_constants[RandomConstants.TRAVEL_DIST],
    )

    # Des électeurs changent leur classement
    self._define_ranking()

    # Des électeurs s&#39;adaptent en changeant leur classement intelligemment
    score_winner = winner.scores[voting_rule]
    change_ranking_electors(
        self.electors,
        score_winner,
        voting_rule,
        VotingRulesConstants.APPROVAL_GAP_COEF,
    )
    # Recalcule des résultats
    self.calc_results()</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.delete_all_data"><code class="name flex">
<span>def <span class="ident">delete_all_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Supprime toutes les données d'une élection. Relance les itérateurs-générateurs des noms, prénoms, IDs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_all_data(self) -&gt; None:
    &#34;&#34;&#34;Supprime toutes les données d&#39;une élection. Relance les itérateurs-générateurs des noms, prénoms, IDs.&#34;&#34;&#34;
    self.electors.clear()
    self.candidates.clear()
    self.results.clear()

    self.first_name_iter.restart()
    self.last_name_iter.restart()
    self.id_iter.restart()

    self.directions_data.clear()</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.has_electors_candidates"><code class="name flex">
<span>def <span class="ident">has_electors_candidates</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Vérifie qu'il existe au moins un électeur et un candidat dans une élection.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> s'il existe au moins un électeur et un candidat dans une élection, sinon <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_electors_candidates(self) -&gt; bool:
    &#34;&#34;&#34;Vérifie qu&#39;il existe au moins un électeur et un candidat dans une élection.

    Returns:
        bool: `True` s&#39;il existe au moins un électeur et un candidat dans une élection, sinon `False`.
    &#34;&#34;&#34;

    if not self.electors and not self.candidates:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.set_avg_electors_position"><code class="name flex">
<span>def <span class="ident">set_avg_electors_position</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calcule la position moyenne des électeurs. Uniquement la division est faite.
La somme de toutes les positions est déjà stockée.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_avg_electors_position(self) -&gt; None:
    &#34;&#34;&#34;Calcule la position moyenne des électeurs. Uniquement la division est faite. 
    La somme de toutes les positions est déjà stockée.&#34;&#34;&#34;

    x_avg, y_avg = self.average_position_electors
    x_avg /= len(self.electors)
    y_avg /= len(self.electors)
    self.average_position_electors = (x_avg, y_avg)</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.set_default_settings"><code class="name flex">
<span>def <span class="ident">set_default_settings</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialise les réglages par défaut.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_settings(self) -&gt; None:
    &#34;&#34;&#34;Initialise les réglages par défaut.&#34;&#34;&#34;

    # Nb de sondages à faire
    self.nb_polls:int = 0
    &#34;&#34;&#34;Un nombre des sondages à faire&#34;&#34;&#34;

    # Active/désactive la démocratie liquide
    self.liquid_democracy_activated = False

    # Une règle de vote pour les sondages
    self.poll_voting_rule = VotingRulesConstants.PLURALITY_SIMPLE

    # Active/désactive un tie-break selon les duels
    self.tie_breaker_activated = True

    # Les constantes de la génération des données
    self.generation_constants = dict()
    for type, default_value in RandomConstants.DEFAULT_VALUES.items():
        self.generation_constants[type] = default_value

    # Pour les sondages uniquement. Stocke les données pour chaque direction (division) de la carte politique
    self.directions_data = get_default_directions_data()</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.set_results"><code class="name flex">
<span>def <span class="ident">set_results</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calcule un classement des candidats selon leurs scores (les scores sont déjà attribués à chaque candidat).
Utilisée lors de l'importation des données. MAJ d'un dictionnaire results.
La fonction ne fait rien s'il n'existe pas au moins un électeur et un candidat.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_results(self) -&gt; None:
    &#34;&#34;&#34;Calcule un classement des candidats selon leurs scores (les scores sont déjà attribués à chaque candidat). 
    Utilisée lors de l&#39;importation des données. MAJ d&#39;un dictionnaire results. 
    La fonction ne fait rien s&#39;il n&#39;existe pas au moins un électeur et un candidat.
    &#34;&#34;&#34;

    if not self.has_electors_candidates():
        return
    # Assuming every candidate has the same voting_rules
    candidate = self.candidates[0]
    keys = candidate.scores.keys()

    duels = self.duels_scores if self.tie_breaker_activated else None
    for voting_rule in keys:
        if voting_rule in VotingRulesConstants.ONE_ROUND:
            result = sort_cand_by_value(self.candidates, voting_rule, nb_electors=len(self.electors), duels=duels)
            self.results[voting_rule] = result

        if voting_rule in VotingRulesConstants.MULTI_ROUND:
            self.results[voting_rule] = [None] * len(candidate.scores[voting_rule])

            for round in range(len(candidate.scores[voting_rule])):
                result = sort_cand_by_round(self.candidates, voting_rule, round)
                self.results[voting_rule][round] = result

        if voting_rule in VotingRulesConstants.CONDORCET:
            sort_asc = (
                True
                if voting_rule == VotingRulesConstants.CONDORCET_SIMPSON
                else False
            )
            result = sort_cand_by_value(self.candidates, voting_rule, nb_electors=len(
                self.electors), duels=None, scores_asc=sort_asc)
            self.results[voting_rule] = result</code></pre>
</details>
</dd>
<dt id="electoral_systems.election.Election.start_election"><code class="name flex">
<span>def <span class="ident">start_election</span></span>(<span>self, imported: Optional[bool] = False, chosen_voting_rules: List[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Commence une élection. Fait tout les calculs nécessaires:<br>
- Chaque électeur définit son classement des candidats<br>
- MAJ de la position moyenne des électeurs<br>
- Calcule le taux de satisfaction<br>
- Si les sondages sont activés, MAJ les données pour chaque direction de la carte politique<br>
- Si la démocratie liquide est activée, fait les délégations<br>
- Initialise un dictionnaire results avec des règles de vote choisies<br>
- Calcule les résultats
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>imported</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd><code>True</code> si les données ont été importées, sinon <code>False</code>.
Cf. <code><a title="electoral_systems.election.Election.calc_results" href="#electoral_systems.election.Election.calc_results">Election.calc_results()</a></code> <electoral_systems.election.Election></dd>
<dt><strong><code>chosen_voting_rules</code></strong> :&ensp;<code>Set[str]</code></dt>
<dd>Une liste des constantes des règles de vote choisies.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_election(self, imported: Optional[bool] = False, chosen_voting_rules: List[str] = None) -&gt; None:
    &#34;&#34;&#34;Commence une élection. Fait tout les calculs nécessaires:  
        - Chaque électeur définit son classement des candidats  
        - MAJ de la position moyenne des électeurs  
        - Calcule le taux de satisfaction  
        - Si les sondages sont activés, MAJ les données pour chaque direction de la carte politique  
        - Si la démocratie liquide est activée, fait les délégations  
        - Initialise un dictionnaire results avec des règles de vote choisies  
        - Calcule les résultats  

    Args:
        imported (Optional[bool]): `True` si les données ont été importées, sinon `False`. 
            Cf. `Election.calc_results()` &lt;electoral_systems.election.Election&gt;
        chosen_voting_rules (Set[str]): Une liste des constantes des règles de vote choisies.
    &#34;&#34;&#34;

    self._define_ranking()
    self.set_avg_electors_position()
    self._calc_proportion_satisfaction()

    # Set data for polls
    if self.nb_polls:
        set_avg_electors_positions(self.directions_data)
        set_std_deviation(self.directions_data, len(self.electors))
    if self.liquid_democracy_activated:
        self._make_delegations()
    if chosen_voting_rules:
        self._init_results_keys(chosen_voting_rules)

    self.calc_results(imported)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="electoral_systems" href="index.html">electoral_systems</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="electoral_systems.election.Election" href="#electoral_systems.election.Election">Election</a></code></h4>
<ul class="">
<li><code><a title="electoral_systems.election.Election._calc_distance" href="#electoral_systems.election.Election._calc_distance">_calc_distance</a></code></li>
<li><code><a title="electoral_systems.election.Election._calc_proportion_satisfaction" href="#electoral_systems.election.Election._calc_proportion_satisfaction">_calc_proportion_satisfaction</a></code></li>
<li><code><a title="electoral_systems.election.Election._define_ranking" href="#electoral_systems.election.Election._define_ranking">_define_ranking</a></code></li>
<li><code><a title="electoral_systems.election.Election._init_results_keys" href="#electoral_systems.election.Election._init_results_keys">_init_results_keys</a></code></li>
<li><code><a title="electoral_systems.election.Election._make_delegations" href="#electoral_systems.election.Election._make_delegations">_make_delegations</a></code></li>
<li><code><a title="electoral_systems.election.Election.add_candidate" href="#electoral_systems.election.Election.add_candidate">add_candidate</a></code></li>
<li><code><a title="electoral_systems.election.Election.add_candidate_import" href="#electoral_systems.election.Election.add_candidate_import">add_candidate_import</a></code></li>
<li><code><a title="electoral_systems.election.Election.add_elector" href="#electoral_systems.election.Election.add_elector">add_elector</a></code></li>
<li><code><a title="electoral_systems.election.Election.add_elector_import" href="#electoral_systems.election.Election.add_elector_import">add_elector_import</a></code></li>
<li><code><a title="electoral_systems.election.Election.apply_voting_rule" href="#electoral_systems.election.Election.apply_voting_rule">apply_voting_rule</a></code></li>
<li><code><a title="electoral_systems.election.Election.calc_results" href="#electoral_systems.election.Election.calc_results">calc_results</a></code></li>
<li><code><a title="electoral_systems.election.Election.calc_satisfaction" href="#electoral_systems.election.Election.calc_satisfaction">calc_satisfaction</a></code></li>
<li><code><a title="electoral_systems.election.Election.candidates" href="#electoral_systems.election.Election.candidates">candidates</a></code></li>
<li><code><a title="electoral_systems.election.Election.choose_condorcet_winner" href="#electoral_systems.election.Election.choose_condorcet_winner">choose_condorcet_winner</a></code></li>
<li><code><a title="electoral_systems.election.Election.choose_winner" href="#electoral_systems.election.Election.choose_winner">choose_winner</a></code></li>
<li><code><a title="electoral_systems.election.Election.conduct_poll" href="#electoral_systems.election.Election.conduct_poll">conduct_poll</a></code></li>
<li><code><a title="electoral_systems.election.Election.delete_all_data" href="#electoral_systems.election.Election.delete_all_data">delete_all_data</a></code></li>
<li><code><a title="electoral_systems.election.Election.duels_scores" href="#electoral_systems.election.Election.duels_scores">duels_scores</a></code></li>
<li><code><a title="electoral_systems.election.Election.electors" href="#electoral_systems.election.Election.electors">electors</a></code></li>
<li><code><a title="electoral_systems.election.Election.first_name_iter" href="#electoral_systems.election.Election.first_name_iter">first_name_iter</a></code></li>
<li><code><a title="electoral_systems.election.Election.has_electors_candidates" href="#electoral_systems.election.Election.has_electors_candidates">has_electors_candidates</a></code></li>
<li><code><a title="electoral_systems.election.Election.id_iter" href="#electoral_systems.election.Election.id_iter">id_iter</a></code></li>
<li><code><a title="electoral_systems.election.Election.last_name_iter" href="#electoral_systems.election.Election.last_name_iter">last_name_iter</a></code></li>
<li><code><a title="electoral_systems.election.Election.proportion_satisfaction" href="#electoral_systems.election.Election.proportion_satisfaction">proportion_satisfaction</a></code></li>
<li><code><a title="electoral_systems.election.Election.results" href="#electoral_systems.election.Election.results">results</a></code></li>
<li><code><a title="electoral_systems.election.Election.set_avg_electors_position" href="#electoral_systems.election.Election.set_avg_electors_position">set_avg_electors_position</a></code></li>
<li><code><a title="electoral_systems.election.Election.set_default_settings" href="#electoral_systems.election.Election.set_default_settings">set_default_settings</a></code></li>
<li><code><a title="electoral_systems.election.Election.set_results" href="#electoral_systems.election.Election.set_results">set_results</a></code></li>
<li><code><a title="electoral_systems.election.Election.start_election" href="#electoral_systems.election.Election.start_election">start_election</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>